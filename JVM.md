## JVM简介

class --> JVM --> OS --> 硬件

JVM运行在OS上,与硬件没有直接交互



### JVM架构模型

Java编译器输入的指令流基本上是一种==基于栈的指令集架构==，另外一种指令集架构则是==基于寄存器的指令集架构==

具体来说：这两种架构之间的区别：

==基于栈式架构的特点==

- 设计和实现更简单，适用于资源受限的系统；
- 避开了寄存器的分配难题：使用零地址指令方式分配。
- 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小
- 编译器容易实现。
- 不需要硬件支持，可移植性更好，更好实现跨平台

==基于寄存器架构的特点==

- 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。
- 指令集架构则完全依赖硬件，可移植性差
- 性能优秀和执行更高效；
- 花费更少的指令去完成一项操作。
- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令
- 和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。



==**栈：跨平台性、指令集小、指令多；执行性能比寄存器差**==



### JVM 生命周期

**虚拟机的启动**

Java虚拟机的启动是通过引导类加载器（bootstrap class loader)创建一个初始类（initial class)来完成的，这个类是由虚拟机的具体实现指定的。

**虚拟机的执行**

- 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。
- 程序开始执行时他才运行，程序结束时他就停止。
- 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。

**虚拟机的退出**

有如下的几种情况：

- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止
- 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。
- 除此之外，JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况



### JVM发展历程

#### #SunClassicVM

- 早在1996年Java1.0版本的时候，Sun公司发布了一款名为Sun Classic VM的Java虚拟机，它同时也是**世界上第一款商用Java虚拟机**，JDK1.4时完全被淘汰。
- 这款虚拟机内部只提供解释器。
- 如果使用JIT (即时编译器) 编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。
- 现在hotspot内置了此虚拟机。

#### Exact VM

- 为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。

- Exact Memory Management:准确式内存管理

- - 也可以叫Non-Conservative/Accurate Memory Management
  - 虚拟机可以知道内存中某个位置的数据具体是什么类型。

- 具备现代高性能虚拟机的维形

- - 热点探测
  - 编译器与解释器混合工作模式

- 只在solaris平台短暂使用，其他平台上还是classic vm 

- - 英雄气短，终被Hotspot虚拟机替换

#### #HotSpot

历史

- 最初由一家名为“Longview Technologies”的小公司设计
- 1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。
- JDK1.3时，HotSpot VM成为默认虚拟机

目前Hotspot占有绝对的市场地位，称霸武林。

- 不管是现在仍在广泛使用的JDK6,还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot
- Sun/Oracle JDK和OpenJDK的默认虚拟机
- 因此本课程中默认介绍的虚拟机都是HotSpot,相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚拟机都没有方法区的概念）

从服务器、桌面到移动端、嵌入式都有应用。

名称中的HotSpot指的就是它的热点代码探测技术。

- 通过计数器找到最具编译价值代码，触发即时编译或栈上替换
- 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡

#### #JRockit

专注于服务器端应用

- 它可以不太关注程序启动速度，因此==JRockit内部不包含解析器实现==，全部代码都靠即时编译器编译后执行。

大量的行业基准测试显示，==JRockit JVM是世界上最快的JVM==。

- 使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%)和硬件成本的减少（达50%)

优势：全面的Java运行时解决方案组合

- JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要
- MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。

2008年，BEA被Oracle收购。

Oracle表达了整合两大优秀虚拟机的工作，大致在JDK 8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。

#### IBM的J9

全称：IBM Technology for Java Virtual Machine,简称IT4J,内部代号：J9

市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM

广泛用于IBM的各种Java产品。

目前，有影响力的三大商用服务器之一，也号称是世界上最快的Java虚拟机。

2017年左右，IBM发布了开源J9VM,命名为OpenJ9,交给Eclipse基金会管理，也称为Ecilpse OpenJ9

#### KVM和CDC/CLDC Hotspot

Oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC Hotspot Implementation VM

KVM(Kilobyte)是CLDC-HI早期产品

目前移动领域地位尴尬，智能手机被Android和iOS二分天下。

KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片

市场

- 智能控制器、传感器
- 老人手机、经济欠发达地区的功能手机

所有的虚拟机的原则：一次编译，到处运行。

#### Azul VM

前面三大“高性能Java虚拟机”使用在通用硬件平台上

这里Azu1 VM和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机

- 高性能Java虚拟机中的战斗机。

Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件vega系统上的Java虚拟机。

每个Azu1 VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。

2010年，Azul systems公司开始从硬件转向软件，发布了自己的Zing JVM,可以在通用x86平台上提供接近于vega系统的特性。

#### Liquid VM

高性能Java虚拟机中的战斗机。

BEA公司开发的，直接运行在自家Hypervisor系统上

Liquid VM即是现在的JRockit VE(Virtual Edition),Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。

·随着JRockit虚拟机终止开发，Liquid VM项目也停止了。

#### Apache Harmony

Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。

它是IBM和Inte1联合开发的开源JVM,受到同样开源的OpenJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK

虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。

#### Microsoft JVM

微软为了在IE3浏览器中支持Java Applets,开发了Microsoft JVM。

只能在window平台下运行。但确是当时windows下性能最好的Java VM。

1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软在windowsXP SP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。

#### #TaobaoJVM

由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。

基于OpenJDK开发了自己的定制版本AlibabaJDK,简称AJDK。是整个阿里Java体系的基石。

基于openJDK HotSpot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。

- 创新的GCIH(GC invisible heap)技术实现了off-heap,即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。
- GCIH中的对象还能够在多个Java虚拟机进程中实现共享
- 使用crc32指令实现JVMintrinsic降低JNI的调用开销
- PMU hardware 的Java profiling tool 和诊断协助功能
- 针对大数据场景的ZenGC

taobao vm应用在阿里产品上性能高，硬件严重依赖intel的cpu,损失了兼容性，但提高了性能

- 目前已经在淘宝、天猫上线，把oracle官方JVM版本全部替换了。

#### Dalvik VM

谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT,发展迅猛。

Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循Jave虚拟机规范

不能直接执行Java的class文件

基于寄存器架构，环是jvm的栈架构。

执行的是编译以后的dex(Dalvik Executable)文件。执行效率比较高。

- 它执行的dex(Dalvik Executable)文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。

Android 5.0使用支持提前编译（Ahead Of Time Compilation,AOT)的ART VM替换Dalvik VM。

#### #GraalVM

2018年4月，Oracle Labs公开了Graal VM,号称"Run Programs Faster Anywhere",勃勃野心。

与1995年java的"write once,run anywhere"遥相呼应。

Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言"的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin;C、C++、JavaScript、Ruby、Python、R等

支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件

工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。

如果说HotSpot有一天真的被取代，Graal VM希望最大。但是Java的软件生态没有丝毫变化。

## java内存区域

### 类加载器子系统

![img](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/clipboard.png)

类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。

classLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。

加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）

![img](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210831101716409.png)

#### 类加载过程

![img](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/clipboard-1630371924397.png)

##### 加载(loading)：

1.通过一个类的全限定名获取定义此类的二进制字节流

2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

3.==在内存中生成一个代表这个类的java.lang.Class对象==，作为方法区这个类的各种数据的访问入口

补充：加载.class文件的方式

- 从本地系统中直接加载
- 通过网络获取，典型场景：web Applet
- 从zip压缩包中读取，成为日后jar、war格式的基础
- 运行时计算生成，使用最多的是：动态代理技术
- 由其他文件生成，典型场景：JSP应用
- 从专有数据库中提取.class文件，比较少见
- 从加密文件中获取，典型的防class文件被反编译的保护措施

##### **链接(linking)**

###### **验证（Verify)**:

- 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
- 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。

###### **准备（Prepare)**:

- ==为类变量分配内存并且设置该类变量的默认初始值，即零值==。
- ==这里不包含用final修饰的static,因为final在编译的时候就会分配了，准备阶段会显式初始化==；
- ==这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中==。

###### **解析（Resolve)**:

- ==将常量池内的符号引用转换为直接引用的过程。==
- 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
- 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。

##### **初始化(initialization)：**

- ==初始化阶段就是执行类构造器方法<clinit>()的过程。==
- 此方法不需定义，是javac编译器自动收集类中的所有==类变量的赋值动作和静态代码块中的语句合并==而来。
- 构造器方法中指令按语句在源文件中出现的顺序执行。
- ==<clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>())==
- 若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕。
- 虚拟机必须保证一个类的<clinit>（)方法在多线程下被同步加锁。

##### 案例

```java
public class ClassInitTest {
    private static int a = 1;
    static {
        a = 2;
        b = 10;
        //Illegal forward reference  非法前向引用
        //System.out.println(b);
    }
    //Linking的prepare: b=10 --> initial:10-->20
    public static int b = 20;
    public static void main(String[] args) {
        System.out.println(a);//2
        System.out.println(b);//20
    }
}
```

![image-20210831092722465](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210831092722465.png)

#### **类加载器分类**

- JVM支持两种类型的类加载器，分别为==引导类加载器（Bootstrap ClassLoader)==和==自定义类加载器(User-Defined ClassLoader)。==
- 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。
- 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：

![image-20210831093301806](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210831093301806.png)

==四者为包含关系,不是继承关系==

```java
//系统类加载器
ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
//上层 扩展类加载器
ClassLoader parent = systemClassLoader.getParent();
//自定义类 系统类加载器
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
```

##### **虚拟机自带的加载器**

###### **启动类加载器（引导类加载器，Bootstrap ClassLoader)**

- 这个类加载==使用C/C++语言实现的==，嵌套在JVM内部。
- 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容）,用于提供JVM自身需要的类
- 并不继承自java.lang.ClassLoader,没有父加载器。
- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
- 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

###### **扩展类加载器（Extension ClassLoader)**

- ==Java语言编写==，由sun.misc.Launcher$ExtClassLoader实现。
- ==派生于classLoader类==
- 父类加载器为启动类加载器
- 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。==如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载==。

###### **应用程序类加载器（系统类加载器，AppClassLoader)**

- java语言编写，由sun.misc.Launcher$AppClassLoader实现
- 派生于ClassLoader类
- 父类加载器为扩展类加载器
- 它负责加载环境变量classpath或系统属性java.class.path定路径下的类库
- ==该类加载是程序中默认的类加载器==，一般来说，Java应用的类都是由它来完成加载
- 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器

```java
//引导类加载器
URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
for (URL urL : urLs) {
    System.out.println(urL);
}
//扩展类加载器
System.getProperty("java.ext.dirs");
```

##### **用户自定义类加载器**

在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。

为什么要自定义类加载器？

- 隔离加载类
- 修改类加载的方式
- 扩展加载源
- 防止源码泄漏

###### 用户自定义类加载器实现步骤：

- 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
- 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadclass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中

- 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁

**ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器）**

![image-20210831094327298](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210831094327298.png)

**获取ClassLoader的途径**

```java
Class.forName("java.long.String").getClassLoader();
Thread.currentThread().getContextClassLoader();
ClassLoader.getSystemClassLoader();
//方式四：获取调用者的ClassLoader
DriverManager.getCallerClassLoader()
```

#### **双亲委派机制**

Java虚拟机对class文件采用的是==按需加载==的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是==双亲委派模式==，即把请求交由父类处理，它是一种任务委派模式。

##### **工作原理**

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；

2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器

3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

![image-20210831095939644](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210831095939644.png)

##### **优势**

- 避免类的重复加载
- 保护程序安全，防止核心API被随意墓改

- - - 自定义类：java.lang.String
    - 自定义类：java.lang.Shkstart

##### **沙箱安全机制**

自定义string类，但是在加载自定义string类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\string.class),报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。

在JVM中表示两个class对象是否为同一个类存在两个必要条件：

- 类的完整类名必须一致，包括包名。
- 加载这个类的classLoader(指classLoader实例对象）必须相同。

换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。

##### **对类加载器的引用**

JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会==将这个类加载器的一个引用作为类型信息的一部分保存在方法区中==。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。

##### **Java程序对类的使用方式：主动使用和被动使用。**

主动使用，又分为七种情况：

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（比如：Class.forName("com.atguigu.Test"))
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类
- JDK7开始提供的动态语言支持：

java.lang.invoke.MethodHandle实例的解析结果

REF_getStatic、REE_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

除了以上七种情况，其他使用Java类的方式都被看作是==对类的被动使用==，都==不会导致类的初始化。==































### 运行时数据区

==不同的JVM对于内存的划分方式和管理机制存在着部分差异==

![image-20210903134143773](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210903134143773.png)

灰色的为单独线程私有的，红色的为多个线程共享的

每个线程：独立包括程序计数器、栈、本地栈。

线程间共享：堆、堆外内存（永久代或元空间、代码缓存）



每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境

- 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。

- 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。

- - 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。

- 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。



如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[])的main线程以及所有这个main线程自己创建的线程。



这些主要的后台系统线程在Hotspot JVM里主要是以下几个：

**虚拟机线程**：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括"stop-the-world"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。

**周期任务线程**：这种线程是时间周期事件的体现（比如中断）,他们一般用于周期性操作的调度执行。

**GC线程**：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。

**编译线程**：这种线程在运行时会将字节码编译成到本地代码。

**信号调度线程**：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。

#### 程序计数器

JVM中的程序计数寄存器（Program Counter Register)中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。

这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子）,并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。

![image-20210903135448404](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210903135448404.png)

**作用：**

==PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。==

![image-20210903135524091](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210903135524091.png)

- 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
- 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned)。
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 它是唯一一个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域。

![image-20210903135803066](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210903135803066.png)



**使用PC寄存器存储字节码指令地址有什么用呢？**

**为什么使用PC寄存器记录当前线程的执行地址呢？**

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。

JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

**PC寄存器为什么会被设定为线程私有？**

==为了准确地记录各个线程正在执行的当前字节码指令地址==

各个线程之间进行独立计算，从而不会出现相互干扰的情况。

由于cpu时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。



















#### 虚拟机栈

由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。

优点是跨平台，指令集小，

缺点是性能下降，实现同样的功能需要更多的指令。编译器容易实现



==栈是运行时的单位，而堆是存储的单位。==



##### **Java虚拟机栈是什么？**

Java虚拟机栈（Java Virtual Machine Stack),早期也叫Java栈。

每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame),对应着一次次的Java方法调用。是线程私有的

**生命周期**

生命周期和线程一致。

**作用**

==主管Java程序的运行，它保存方法的局部变量(基本数据类型,引用数据类型地址)、部分结果，并参与方法的调用和返回。==



##### **栈的特点（优点）**

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。

- JVM直接对Java栈的操作只有两个：

- - 每个方法执行，伴随着进栈（入栈、压栈）
  - 执行结束后的出栈工作

- 对于栈来说不存在垃圾回收问题



##### **栈中可能出现的异常**

Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。

如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个==StackoverflowError==异常。

如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个==OutofMemoryError==异常。

```shell
#设置栈内存大小
-Xss 1/1k/1m/1g
```

- 每个线程都有自己的栈，栈中的数据都是以==栈帧（stack Frame)==的格式存在。
- 在这个线程上正在执行的每个方法都各自对应一个栈帧（stack Frame)。
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

- JVM直接对Java栈的操作只有两个，就是对栈帧的==压栈==和==出栈==，遵循“先进后出”“后进先出”原则。
- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧(Current Frame),与当前栈帧相对应的方法就是当前方法（CurrentMethod),定义这个方法的类就是当前类（Current Class)。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
- Java方法有两种返回函数的方式，==一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出==。

##### **栈侦的内部结构**

每个栈帧中存储着：

- ==局部变量表（Local Variables)==
- ==操作数栈（operand stack)(或表达式栈）==
- 动态链接（Dynamic Linking)(或指向运行时常量池的方法引用）
- 方法返回地址（Return Address)(或方法正常退出或者异常退出的定义）
- 一些附加信息

![image-20210903141742526](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210903141742526.png)

###### **局部变量表（Local Variables)**

- 局部变量表也被称之为局部变量数组或本地变量表
- ==定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量==这些数据类型包括各类基本数据类型、对象引用（reference),以及returnAddress类型。
- 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此==不存在数据安全问题==
- ==局部变量表所需的容量大小是在编译期确定下来的==，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。

- ==方法嵌套调用的次数由栈的大小决定==。一般来说，==栈越大，方法嵌套调用次数越多==。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。
- ==局部变量表中的变量只在当前方法调用中有效==。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。==当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁==。



**slot**

- 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。
- 局部变量表，==最基本的存储单元是slot(变量槽）==
- 局部变量表中存放编译期可知的各种基本数据类型（8种）,引用类型(reference),returnAddress类型的变量。
- 在局部变量表里，32位以内的类型只占用一个slot(包括returnAddress类型）,64位的类型（long和double)占用两个slot。

- - byte、short、char在存储前被转换为int,boolean也被转换为int,0表示false,非0表示true。
  - long和double则占据两个slot。

- JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会==按照顺序被复制==到局部变量表中的每一个slot上
- ==如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可==。（比如：访问long或double类型变量）
- 如果当前帧是由==构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处==，其余的参数按照参数表顺序继续排列。



**Slot的重复利用**

==栈帧中的局部变量表中的槽位是可以重用的==，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

![image-20210903142603766](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210903142603766.png)



**举例：静态变量与局部变量的对比。**

参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。

我们知道类变量表有两次初始化的机会，第一次是在“==准备阶段==”，执行系统初始化，对类变量设置零值，另一次则是在“==初始化==”阶段，赋子程序员在代码中定义的初始值。

和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。

在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。

==局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。==

###### **操作数栈（operand stack)(或表达式栈）**

- 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack)。

- ==操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push)/出栈（pop)。==

- - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作x`

- 操作数栈，==主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。==

- 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，==这个方法的操作数栈是空的。==

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在==编译期就定义好了，保存在方法的Code属性中，为max_stack的值。==

- 栈中的任何一个元素都是可以任意的Java数据类型。

- - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用两个栈单位深度

- 操作数栈==并非采用访问索引的方式来进行数据访问的==，而是只能通过标准的入栈（push)和出栈（pop)操作来完成一次数据访问。

- ==如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，==并更新PC寄存器中下一条需要执行的字节码指令。

- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。

- 另外，我们说Java虚拟机的==解释引擎是基于栈的执行引擎==，其中的栈指的就是==操作数栈==



**栈顶缓存（Tos,Top-of-Stack Cashing)技术**

前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch)次数和内存读/写次数。

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，**HotSpot JVM的设计者们提出了栈顶缓存（Tos,Top-of-Stack Cashing)技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率**。

###### **动态链接（或指向运行时常量池的方法引用）**

- 每一个栈帧内部都包含一个指向==运行时常量池==中==该栈帧所属方法的引用==。包含这个引用的目的就是为了支持当前方法的代码能够实现==动态链接(Dynamic Linking)==。比如：invokedynamic指令
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么==动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。==

![image-20210923093909342](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20210923093909342.png)

常量池的作用，就是为了提供一些符号和常量，便于指令的识别



**方法的调用**

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

==静态链接：==

当一个字节码文件被装载进JVM内部时，如果被调用的目==标方法在编译期可知，且运行期保持不变时==。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。

==动态链接：==

如果==被调用的方法在编译期无法被确定下来==，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。



对应的方法的绑定机制为：早期绑定（Early Binding)和晚期绑定(Late Binding)。==绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。==

==早期绑定：==

早期绑定就是指被调用的目标方法==如果在编译期可知，且运行期保持不变==时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

==晚期绑定：==

如果==被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法==，这种绑定方式也就被称之为晚期绑定。



随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性既然==这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。==

Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Jave程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法



**方法的调用：虚方法与非虚方法**

**非虚方法**：

- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的这样的方法称为==非虚方法。==
- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。



虚拟机中提供了以下几条方法调用指令：

普通调用指令：

1. ==invokestatic:调用静态方法，解析阶段确定唯一方法版本==

2. ==invokespecial:调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本==

3. invokevirtual:调用所有虚方法

4. invokeinterface:调用接口方法

动态调用指令：

5. invokedynamic:动态解析出需要调用的方法，然后执行



前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中==invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。==



**invokedynamic**

JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个**invokedynamic**指令，这是==Java为了实现[动态类型语言]支持而做的一种改进。==

但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。==直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。==

Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。



**方法的调用：方法重写的本质**

Java 语言中方法重写的本质：

1.找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。

2.如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过,则返回java.lang.IllegalAccessError异常。

3.否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。

4.如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError异常。



**IllegalAccessError介绍：**

程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。



**虚方法表(virtual method table)**

- 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，==为了提高性能==，JVM采用在类的方法区建立一个==虚方法表(virtual method table)(非虚方法不会出现在表中）来实现。使用索引表来代替查找。==

- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。

- 那么虚方法表什么时候被创建？

  虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。



###### **方法返回地址(return address)**

- 存放调用该方法的pc寄存器的值。

- 一个方法的结束，有两种方式：

- - 正常执行完成
  - 出现未处理的异常，非正常退出

- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，==调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址==。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息

本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

==正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。==



当一个方法开始执行后，只有两种方式可以退出这个方法：

1、执行引擎遇到任意一个方法返回的字节码指令（return),会有返回值传递给上层的方法调用者，简称==正常完成出口==；

- 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。
- 在字节码指令中，返回指令包含ireturn(当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn,另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。

2、在方法执行的过程中遇到了异常（Exception),并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称==异常完成出口。==

方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。

###### **一些附加信息**

栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。



##### **栈的相关面试题**

- 举例栈溢出的情况？(StackOverflowError)

- - 通过-Xss设置栈的大小；OOM

- 调整栈大小，就能保证不出现溢出吗？不能

- 分配的栈内存越大越好吗？不是！

- 垃圾回收是否会涉及到虚拟机栈？不会的！

- 方法中定义的局部变量是否线程安全？具体问题具体分析

  内部产生内部消亡 安全

  内部产生 返回  不安全

#### 本地方法栈

- ==Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。==

- 本地方法栈，也是线程私有的。

- 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）

- - 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 stackoverflowError异常。
  - 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutofMemoryError异常。

- 本地方法是使用c语言实现的。

- 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。

![image-20211122172506591](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122172506591.png)

- ==当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限==。

- - 本地方法可以通过本地方法接口来==访问虚拟机内部的运行时数据区==。
  - 它甚至可以直接使用本地处-理器中的寄存器
  - 直接从本地内存的堆中分配任意数量的内存。

- ==并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等==。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。

- 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。





#### 堆

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。

- Java 堆区在JVM 启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。

- - 堆内存的大小是可以调节的。

- 《Java虚拟机规范》规定，堆可以处于==物理上不连续==的内存空间中，但在==逻辑上连续==。

- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（ThreadLocal Allocation Buffer, TLAB)。

- 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated )

- - 我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。

- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。

- 堆，是GC(Garbage Collection,垃圾收集器）执行垃圾回收的重点区域。



**现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：**

- Java7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区

- - Young Generation Space 新生区 Young/New

  - - 又被划分为Eden区和Survivor区

  - Tenure generation space 养老区 old/Tenure

  - Permanent Space 永久区 Perm

- Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间

- - Young Generation Space 新生区 Young/New

  - - 又被划分为Eden区和Survivor区

  - Tenure generation space 养老区  old/Tenure

  - Meta Space 元空间 Meta



Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项”-Xmx”和“-Xms”来进行设置。

```shell
"-Xms"用于表示堆区的起始内存，等价于-XX:InitialHeapSize
"-Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize

Runtime.getRuntime().totalMemory();
Runtime.getRuntime().maxMemory();
```

一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出OutOfMemoryError异常。

通常会将-Xms和-Xmx两个参数配置相同的值，其==目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。==

默认情况下，初始内存大小：物理电脑内存大小/64

最大内存大小：物理电脑内存大小/4

##### **配置新生代与老年代在堆结构的占比**

```shell
默认-XX:NewRatio=2,表示新生代占1,老年代占2,新生代占整个堆的1/3
可以修改-XX:NewRatio=4,表示新生代占1,老年代占4,新生代占整个堆的1/5

-XX:SurvivorRatio:设置新生代中Eden区与survivor区的比例,默认是8
-XX:-UseAdaptivesizepolicy:关闭自适应的内存分配策略（暂时用不到）关了也不是8:1:1

-XX:MaxTenuringThreshold=<N>  设置对象去老年代的阈值
```

- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8

- ==几乎所有==的Java对象都是在Eden区被new出来的。

- 绝大部分的Java对象的销毁都在新生代进行了。

- - IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。

- 可以使用选项”-Xmn"设置新生代最大内存大小

- - 这个参数一般使用默认值就可以了。





JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。

针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC),一种是整堆收集（FullGC)

- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：

- - 新生代收集（Minor GC/Young GC):只是新生代（Eden\S0,S1)的垃圾收集

- 老年代收集（Major GC/01d GC):只是老年代的垃圾收集。

- - 目前，只有CMS GC会有单独收集老年代的行为。
  - ==注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。==

- 混合收集（MixedGC):收集整个新生代以及部分老年代的垃圾收集。

- - 目前，只有G1GC会有这种行为

- 整堆收集（FullGC):收集整个java堆和方法区的垃圾收集。



##### **年轻代GC(Minor GC)触发机制：**

- 当年轻代空间不足时，就会触发Minor GC,这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）
- 因为Java对象大多都具备==朝生夕灭==的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
- Minor GC会引发STW,暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

##### **老年代GC(Major GC/Full GC)触发机制：**

- 指发生在老年代的GC,对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。

- 出现了Major GC,经常会伴随至少一次的Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。

- - 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC

- Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。

- 如果Major GC后，内存还不足，就报OOM了。

- Major GC的速度一般会比Minor GC慢10倍以上。

##### **FullGC触发机制：**

触发Full GC执行的情况有如下五种：

(1)调用system.gc()时，系统建议执行Full GC,但是不必然执行

(2)老年代空间不足

(3)方法区空间不足

(4)通过Minor GC后进入老年代的平均大小大于老年代的可用内存

(5)由Eden区、survivor spacee(From Space)区向survivor space1(To space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

说明：==full gc是开发或调优中尽量要避免的。这样暂时时间会短一些==。



##### **为什么需要把Java堆分代？不分代就不能正常工作了吗？**

其实不分代完全可以，分代的唯一理由就是==优化GC性能==。



##### **内存分配策略（或对象提升（Promotion)规则）**

- 针对不同年龄段的对象分配原则如下所示：

- 优先分配到Ederi

- 大对象直接分配到老年代

- - 尽量避免程序中出现过多的大对象

- 长期存活的对象分配到老年代

- 动态对象年龄判断

- - 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

- 空间分配担保

- - -XX:HandlePromotionFailure

##### **为什么有TLAB(Thread Local Allocation Buffer)?**

- 堆区是线程共享区域，任何线程都可以访间到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

###### **什么是TLAB?**

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，==JVM为每个线程分配了一个私有缓存区域==，它包含在Eden空间内。
- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为==快速分配策略==。
- 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。





#### 方法区

### JNI

### 本地方法接口

![image-20211122172050366](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122172050366.png)



==一个Native Method就是一个Java调用非Java代码的接口==。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern"C"-告知C++编译器去调用一个c的函数。

"A native method is a Java method whose implementation is provided by non-java code."

在定义一个native method时，并不提供实现体（有些像定义一个Java interface),因为其实现体是由非java语言在外面实现的。

本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合c/C++程序。



==标识符native可以与所有其它的java标识符连用，但是abstract除外。==



#### **为什么要使用Native Method?**

**与Java环境外交互：**

==有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因==。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

**与操作系统交互：**

JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。==通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的==。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

 **Sun's Java**

==sun的解释器是用c实现的，这使得它能像一些普通的c一样与外部交互==。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo()。这个本地方法是用c实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 setpriority()API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library)提供，然后被JVM调用。

==目前该方法使用的越来越少了，除非是与硬件有关的应用==，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。





















































































































### 执行引擎







## GC

### GC概述

垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。

关于垃圾收集有三个经典问题：

- 哪哪些内存需要回收？
- 什么时候回收？
- 如何回收？

垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。



#### **面试题**

蚂蚁金服：

你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和g1

一面：JVMGC算法有哪些，目前的JDK版本采用什么回收算法

一面：G1回收器讲下回收过程

GC是什么？为什么要有GC?

一面：GC的两种判定方法？CMS收集器与G1收集器的特点。

百度：

说一下GC算法，分代回收说下

垃圾收集策略和算法

天猫：

一面：jvm GC原理，JVM怎么回收内存

一面：CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？

滴滴：

一面：java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃

圾回收器的

京东：

你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1,包括原理，流程，优缺点。

垃圾即收算法的实现原理。

阿里：

讲一讲垃圾回收算法。

什么情况下触发垃圾回收？

如何选择合适的垃圾收集算法？

JVM有哪三种垃圾回收器？

字节跳动：

常见的垃圾回收器算法有哪些，各有什么优劣？

system.gc()和runtime.gc()会做什么事情？

一面：Java GC机制？GC Roots有哪些？

二面：Java对象的回收方式，回收算法。

CMS和G1了解么，CMS解决什么问题，说一下回收的过程。

CMS回收停顿了几次，为什么要停顿两次。



#### **什么是垃圾?**

垃圾是指在==运行程序中没有任何指针指向的对象==，这个对象就是需要被回收的垃圾。

An object is considered garbage when it can no longer be reached from any pointer in the running program.

如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能==导致内存溢出。==



#### **为什么需要GC?**

- 对于高级语言来说，一个基本认知是如果不进行垃圾回收，==内存迟早都会被消耗完==，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
- 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便==JVM将整理出的内存分配给新的对象==。
- 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，==没有GC就不能保证应用程序的正常进行==。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。



**早期GC**

- 在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。
- 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来==频繁申请和释放内存的管理负担==。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生==内存泄漏==，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成==应用程序崩溃。==
- 现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式已经成为现代开发语言必备的标准。



**JAVA  GC**

- 自动内存管理[无需开发人员手动参与内存的分配与回收，这样==降低内存泄漏和内存溢出的风险==

- - 没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。

- 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以==更专心地专注于业务开发==

- oracle官网关于垃圾回收的介绍

- - https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html

- 对于Java开发人员而言[自动内存管理就像是一个黑厘子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会==弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。==
- 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地根据错误异常日志定位问题和解决问题。
- 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术==实施必要的监控和调节。==

- 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。

- - 其中，Java==堆是垃圾收集器的工作重点。==

- 从次数上讲：

- - ==频繁收集Young区==
  - ==较少收集ld区==
  - ==基本不动Perm区(元空间)==

### GC算法

#### **垃圾标记阶段**

- 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先==需要区分出内存中哪些是存活对象，哪些是已经死亡的对象==。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为==垃圾标记阶段。==
- 那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。
- 判断对象存活一般有两种方式：引用计数算法和可达性分析算法。



##### **引用计数算法（Reference Counting)**

- 比较简单，对每个对象保存一个整型的==引用计数器属性。用于记录对象被引用的情况==。

- 对于一个对象A,只要有任何一个对象引用了A,则A的引用计数器就加1;当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0,即表示对象A不可能再被使用，可进行回收。

- 优点：==实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性==。

- 缺点：

- - 它需要单独的字段存储计数器，这样的做法增加了==存储空间的开销==。
  - 每次赋值都需要更新计数器，伴随着加法和减法操作，这==增加了时间开销==。
  - ==无法处理循环引用==。这是一条致命缺陷，导致Java的垃圾回收器没有使用这类算法。

- 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python,它更是同时支持引用计数和垃圾收集机制。

- 具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。

- Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。

- Python如何解决循环引用？

- - 手动解除：很好理解，就是在合适的时机，解除引用关系。
  - 使用弱引用weakref,weakref是Python提供的标准库，旨在解决循环引用。



##### **可达性分析**

- 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地==解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。==
- 相较于引用计数算法，这里的可达性分析就是==Java、C#==选择的。这种类型的垃圾收集通常也叫作==追踪性垃圾收集==（Tracing Garbage Collection)。

- 所谓"GC Roots"根集合就是一组必须活跃的引用。

- 基本思路：

- - 可达性分析算法是以根对象集合（GC Roots)为起始点，按照从上至下的方式==搜索被根对象集合所连接的目标对象是否可达。==
  - 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为==引用链（Reference Chain)==
  - 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
  - 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。



##### **GC Roots包括以中几类元素：**

- 虚拟机栈中引用的对象

- - 比如：各个线程被调用的方法中使用到的参数、局部变量等。

- 本地方法栈内JNI(通常说的本地方法）引用的对象

- 方法区中类静态属性引用的对象

- - 比如：Java类的引用类型静态变量

- 方法区中常量引用的对象

- - 比如：字符串常量池（stringTable)里的引用

- 所有被同步锁synchronized持有的对象

- Java虚拟机内部的引用。

- - 基本数据类型对应的class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError),系统类加载器。

- 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

- 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC)。

- - 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代）,必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。

- 小技巧：

- - 由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。

- 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。
- 这点也是导致GC进行时必须"stop The World"的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，==枚举根节点时也是必须要停顿的。==

##### **MAT与JProfiler的GC Roots溯源**

MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。

MAT是基于Eclipse开发的，是一款免费的性能分析工具。

可以在http://www.eclipse.org/mat/下载并使用MAT。



方式1:命令行使用jmap

```shell
jmap -dump:format=b,live,file=test1.bin 14036
```

方式2:使用JVisualVM导出

- 捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。

- 可通过以下方法捕获heap dump:

- - 在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump(堆Dump)。
  - 在Monitor(监视）子标签页中点击Heap Dump(堆Dump)按钮。

- 本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application(应用程序）栏中对应一个含有时间戳的节点右击这个节点选择save as(另存为）即可将heap dump保存到本地。





##### **对象的finalization机制**

- Java语言提供了对象终止（finalization)机制来允许开发人员提供==对象被销毁之前的自定义处理逻辑。==
- 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
- finalize()方法允许在子类中被重写，==用于在对象被回收时进行资源释放== 通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。



**永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：**

- 在finalize()时可能会导致对象复活。
- finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC,则finalize()方法将没有执行机会。
- 一个糟糕的finalize()会严重影响GC的性能。



从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。



**由于finalize()方法的存在，虚拟机中的对象一般处于==三种可能的状态==**

如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。==一个无法触及的对象有可能在某一个条件下“复活”自己==，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：

- 可触及的：从根节点开始，可以到达这个对象。
- 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。
- 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。

以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。



判定一个对象objA是否可回收，至少要经历两次标记过程：

1.如果对象objA到GC Roots没有引用链，则进行第一次标记。

2.进行筛选，判断此对象是否有必要执行finalize()方法

- ①如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
- ②如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。
- ③==finalize()方法是对象逃脱死亡的最后机会==，稍后GC会对F-Queue队列中的对象进行第二次标记。==如果objA在finalize()方法中与引用链上的任何一个对象建立了联系==，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。





#### **清除阶段**

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。

目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep)、复制算法（Copying)、标记-压缩算法（Mark-Compact )。

##### **标记一清除算法（Mark-Sweep)**

背景：

- 标记-清除算法（Mark-Sweep)是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。

执行过程：

- 当堆中的有效内存空间（available memory)被耗尽的时候，就会停止整个程序（也被称为stop the world),然后进行两项工作，第一项则是标记，第二项则是清除。

- - 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。==一般是在对象的Header中记录为可达对象==。
  - 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

**缺点**

- 效率不算高
- 在进行GC的时候，需要停止整个应用程序，导致用户体验差
- 这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表

注意：何为清除？

- 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。



##### **复制算法（Copying)**

背景：

- 为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CALISP Garbage Collector Algorithm Using Serial Secondary Storage)"。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying)算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。

核心思想：

- 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

**优点**：

- 没有标记和清除过程，实现简单，运行高效
- 复制过去以后保证空间的连续性，不会出现“碎片”问题。

**缺点**：

- 此算法的缺点也是很明显的，就是需要两倍的内存空间。
- 对于G1这种分拆成为大量region的GC,复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。

**特别的：**

- 如果系统中的垃圾对象很少，此算法不理想, 复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。
- 即特别适合垃圾对象很多，存活对象很少的场景；例如：Young区的Survivoro和Survivor1区

应用场景：

- 在新生代，对常规应用的垃圾回收，一次通常可以回收70号-99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。





##### **标记-压缩（或标记-整理、Mark-Compact)算法**

**背景：**

- 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，==基于老年代垃圾回收的特性，需要使用其他的算法。==
- 标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact)算法由此诞生。
- 1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。

**执行过程**：

- 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象
- 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。

- 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为==标记-清除-压缩（Mark-Sweep-Compact)算法。==
- 二者的本质差异在于标记-清除算法是一种==非移动式的回收算法==，标记-压缩是==移动式的==。是否移动回收后的存活对象是一项优缺点并存的风险决策。
- 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

**优点：**

- 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
- 消除了复制算法当中，内存减半的高额代价。

**缺点：**

- 从效率上来说，标记-整理算法要低于复制算法。
- 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。
- 移动过程中，需要全程暂停用户应用程序。即：STW

**指针碰撞（Bump the Pointer)。**

如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer)。







|          | Mark-Sweep         | Mark-Compact    | Copying                               |
| -------- | ------------------ | --------------- | ------------------------------------- |
| 速度     | 中等               | 最慢            | 最快                                  |
| 空间开销 | 少（但会堆积碎片） | 少（不堆积碎片) | 通常需要活对象的2倍大小（不堆积碎片） |
| 移动对象 | 否                 | 是              | 是                                    |

效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。

而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。



##### **分代收集算法**

- 前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。
- 分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，==不同生命周期的对象可以采取不同的收集方式，以便提高回收效率==。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。
- 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如==Http请求中的Session对象、线程、Socket连接==，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：==string对象==，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。

- ==目前几乎所有的GC都是采用分代收集（Generational Collecting)算法执行垃圾回收的。==

- 在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。

- - 年轻代（Young Gen)

  - - 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。
    - 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。

  - 老年代（Tenured Gen)

  - - 老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
    - 这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。

- Mark阶段的开销与存活对象的数量成正比。

- sweep阶段的开销与所管理区域的大小成正相关。

- Compact阶段的开销与存活对象的数据成正比。

- 以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时）,将采用Serial old执行Full GC以达到对老年代内存的整理。
- 分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。



##### **增量收集算法**

上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the world的状态。在==stop the world== 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，==将严重影响用户体验或者系统的稳定性==。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting)算法的诞生。

**基本思想**

- 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，==垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成==。
- 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过==对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。==

**缺点：**

- 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，==造成系统吞吐量的下降。==





##### **分区算法**

- 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。
- 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。
- 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。



注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。



### GC相关概念

#### **System.gc()的理解**

- 在默认情况下，通过System.glc()或者Runtime.getRuntime().gc()的调用，==会显式触发Full GC,==同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。
- 然而system.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。
- JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，==无须手动触发，否则就太过于麻烦了==。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。
- ==System.runFinalization()==;//强制调用使用引用的对象的finalize()方法

![123](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/123.png)



#### **内存溢出(oom)**

- 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。
- 由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。
- 大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。
- javadoc中对OutofMemoryError的解释是，==没有空闲内存，并且垃圾收集器也无法提供更多内存。==
- 首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：

- - **(1)Java虚拟机的堆内存设置不够。**

  - - 比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms、-Xmx来调整。

  - **(2)代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）**

  - - 对于老版本的Oracle JDK,因为永久代的大小是有限的，并且JVM对永久代垃圾回收(如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“==java.lang.OutofMemoryError:PermGen space=="。

- 随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM,异常信息则变成了：“==java.lang.OutOfMemoryError:Metaspace=="。直接内存不足，也会导致OOM。

- 这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。

- - 例如：在引用机制分析中，涉及到JVM会去尝试==回收软引用指向的对象等==。
  - 在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。

- 当然，也不是在任何情况下垃圾收集器都会被触发的

- 比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。

#### **内存泄漏（Memory Leak)**

- 也称作“存储渗漏”。==严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。==
- 但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM,也可以叫==做宽泛意义上的“内存泄漏”。==
- 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。
- 注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。

**举例：**

- 1、单例模式

- - 单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。

- 2、一些提供close的资源未关闭导致内存泄漏

- - 数据库连接（dataSourse.getConnection()),网络连接（socket)和io连接必须手动close,否则是不能被回收的。





#### **Stop The World**

- Stop-the-World,简称STW,指的是GC事件发生过程中，会产生应用程序的停顿。==停顿产生时整个应用程序线程都会被暂停，没有任何响应，==有点像卡死的感觉，这个停顿称为STW。

- - 可达性分析算法中枚举根节点（GC Roots)会导致所有Java执行线程停顿。

  - - 分析工作必须在一个能确保一致性的快照中进行
    - 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
    - ==如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证==

- 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。

- STW事件和采用哪款GC无关，所有的GC都有这个事件。
- 哪怕是G1也不能完全避免stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。
- STW是JVM在==后台自动发起和自动完成的==。在用户不可见的情况下，把用户正常的工作线程全部停掉。
- 开发中不要用System.gc();会导致stop-the-world的发生。

#### **垃圾回收的并行与并发**

##### **并发（Concurrent)**

- 在操作系统中，是指==一个时间段==中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。
- 并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间）,然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。

![image-20211122152908981](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122152908981.png)



##### **并行（Parallel)**

- 当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel)。
- 其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。
- 适合科学计算，后台处理等弱交互场景

![image-20211122152937011](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122152937011.png)



二者对比：

并发，指的是多个事情，==在同一时间段内同时发生了==。

并行，指的是多个事情，==在同一时间点上同时发生了。==

并发的多个任务之间是互相抢占资源的。

并行的多个任务之间是不互相抢占资源的。

只有在多CPU或者一个CPU多核的情况中，才会发生并行。

否则，看似同时发生的事情，其实都是并发执行的。



##### **垃圾回收的并发与并行**

- 并行（Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。

- - 如ParNew、Parallel Scavenge、Parallel old;

- 串行（Serial)

- - 相较于并行的概念，单线程执行。
  - 如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。

![image-20211122153059717](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122153059717.png)



- 并发（Concurrent):指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）,垃圾回收线程在执行时不会停顿用户程序的运行。

- - 用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；
  - 如：CMS、G1

![image-20211122153127231](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122153127231.png)



#### **安全点与安全区域**

##### **安全点（Safepoint)**

- 程序执行时并非在所有地方都能停顿下来开始GC,只有在特定的位置才能停顿下来开始GC,这些位置称为“安全点（Safepoint)”。
- Safe Point的选择很重要，==如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题==。大部分指令的执行时间都非常短暂，通常会根据“==是否具有让程序长时间执行的特征==”为标准。比如：选择一些执行时间较长的指令作为Safe Point,==如方法调用、循环跳转和异常跳转等==。



如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？

- 抢先式中断：(目前没有虚拟机采用了）

  首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。

- 主动式中断：

  设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。



##### **安全区域（Safe Region)**

- Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region)来解决。
- ==安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的==。我们也可以把 Safe Region 看做是被扩展了的Safepoint。



实际执行时：

1. 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC,JVM会忽略标识为Safe Region状态的线程；

2. 当线程即将离开Safe Region时，会检查JVM是否已经完成GC,如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；



#### **强引用、软引用、弱引用、虚引用**

在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（strong Reference)、软引用（Soft Reference)、弱引用（Weak Reference)和虚引用(Phantom Reference)4种，==这4种引用强度依次逐渐减弱。==

除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。

![image-20211122153702413](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122153702413.png)



Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public,可以在应用程序中直接使用

**强引用（StrongReference)**:无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

**软引用（SoftReference)**:在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常

**弱引用（WeakReference)**:被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。

**虚引用（PhantomReference)**:一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的==唯一目的就是能在这个对象被收集器回收时收到一个系统通知。==



##### **强引用（Strong Reference)——不回收**

- 在Java程序中，最常见的引用类型是强引用（==普通系统99%以上都是强引用==）,也就是我们最常见的普通对象引用，==也是默认的引用类型==。
- 当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。
- ==强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象==
- 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null,就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。
- 相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，==强引用是造成Java内存泄漏的主要原因之一==。

##### **软引用（Soft Reference)一内存不足即回收**

- 软引用是用来描述一些还有用，但非必需的对象。==只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收==，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- 软引用通常用来实现内存敏感的缓存。比如：==高速缓存==就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
- 垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue)。
- 类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。

```java
String s2 = "aa";//声明强引用
final WeakReference<String> stringWeakReference = new WeakReference<>(s2);
s2 = null;//销毁强引用
```

##### **弱引用（Weak Reference)一发现即回收**

- 弱引用也是用来描述那些非必需对象，==只被弱引用关联的对象只能生存到下一次垃圾收集发生为止==。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。
- 但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，==弱引用对象可以存在较长的时间==。
- 弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。
- ==软引用、弱引用都非常适合来保存那些可有可无的缓存数据==。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。
- ==弱引用对象与软引用对象的最大不同就在于==，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。==弱引用对象更容易、更快被GC回收。==

面试题：你开发中使用过WeakHashMap吗？





##### **虚引用（Phantom Reference)一对象回收跟踪**

- 也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。
- 一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。
- 它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。
- ==为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。==

- 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。
- ==由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。==
- 在JDK 1.2版之后提供了PhantomReference类来实现虚引用。

```java
new PhantomReference<Object>(new Object(), new ReferenceQueue<>());
```

##### **终结器引用（Final reference)**

- 它用以实现对象的finalize()方法，也可以称为终结器引用。
- 无需手动编码，其内部配合引用队列使用。
- 在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。



### 垃圾回收器

#### **垃圾回收器概述**

- 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。
- 由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。
- 从不同角度分析垃圾收集器，可以将GC分为不同的类型。

#### **GC分类**

##### **按==线程数==分，可以分为串行垃圾回收器和并行垃圾回收器。**

![image-20211122133601758](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122133601758.png)



- 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。

- - 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，==串行回收默认被应用在客户端的Client模式下的JVM中==
  - 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。

- 和串行回收相反-，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-world”机制。

##### **按照==工作模式==分，可以分为并发式垃圾回收器和独占式垃圾回收器。**

- 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。
- 独占式垃圾回收器（Stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。

![image-20211122133802237](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122133802237.png)



##### **按==碎片处理方式==分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。**

- 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。
- 非压缩式的垃圾回收器不进行这步操作。

##### **按==工作的内存区间==分，又可分为年轻代垃圾回收器和老年代垃圾回收器。**



#### **评估GC的性能指标**

- ==吞吐量：运行用户代码的时间占总运行时间的比例==

- - (总运行时间：程序的运行时间+内存回收的时间）

- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。

- **==暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。==**

- 收集频率：相对于应用程序的执行，收集操作发生的频率。

- ==内存占用：Java堆区所占的内存大小。==

- 快速：一个对象从诞生到被回收所经历的时间。

- 这三者共同构成一个工“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。

- 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。

- 简单来说，主要抓住两点：

- - 吞吐量
  - 暂停时间



##### **评估GC的性能指标：吞吐量（throughput)**

- 吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间）。

- - 比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

- 这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。

- 吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=0.4



##### **评估GC的性能指标：暂停时间（pause time)**

- “暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态

- - 例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用

- 程序线程是活动的。

- 暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1+0.1+0.1+0.1=0.5



**吞吐量VS暂停时间**

- 高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。

- 低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，==有时候甚至短暂的200毫秒暂停都可能打断终端用户体验==。因此，具有低的暂停时间是非常重要的，特别是对于一个==交互式应用程序==。

- 不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。

- - 因为如果选择以吞吐量优先，那么==必然需要降低内存回收的执行频率==，但是这样会导致GC需要更长的暂停时间来执行内存回收。
  - 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也==只能频繁地执行内存回收==，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。

- 在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间）,或尝试找到一个二者的折衷。
- 现在标准：==在最大吞吐量优先的情况下，降低停顿时间。==



#### **垃圾收集器发展史**

有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection,对应的产品我们称为Garbage Collector。

- 1999年随JDK1.3.1一起来的是串行方式的Serial GC,它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本
- 2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2-起发布Parallel GC在JDK6之后成为HotSpot默认GC。
- 2012年，在JDK1.7u4版本中，G1可用。
- 2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。
- 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。
- 2018年9月，JDK11发布。引入Epsilon垃圾回收器，又被称为"No-Op(无操作）"回收器。同时，引入ZGC:可伸缩的低延迟垃圾回收器（Experimental)。
- 2019年3月，JDK12发布。增强G1,自动返回未用堆内存给操作系统。同时，引入Shenandoah GC:低停顿时间的GC(Experimental)。
- 2019年9月，JDK13发布。增强ZGC,自动返回未用堆内存给操作系统。
- 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用



#### **7款经典的垃圾收集器**

串行回收器：Serial、Serial old

并行回收器：ParNew、Parallel Scavenge、Parallel old

并发回收器：CMS、G1

https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf

![image-20211122134421647](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122134421647.png)



新生代收集器：Serial、ParNew、Parallel Scavenge;

老年代收集器：Serial old、Parallel old、CMS;

整堆收集器：G1;

![image-20211122134452834](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122134452834.png)

1. 两个收集器间有连线，表明它们可以搭配使用：

   Serial/Serial old、

   Serial/CMS、

   ParNew/Serial old、

   ParNew/CMS、

   Parallel Scavenge/Serial old、

   Parallel Scavenge/Parallel old、

   G1;

2. 其中Serial old作为CMS出现"Concurrent Mode Failure"失败的后备预案。

3. (红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、

   ParNew+Serial old这两个组合声明为废弃（JEP 173),并在JDK 9中完全取消了

   这些组合的支持（JEP214),即：移除。

4. (绿色虚线）JDK 14中：弃用Parallel Scavenge和Serial old GC组合（JEP366)

5. (青色虚线）JDK 14中：删除CMS垃圾回收器（JEP 363)



我们选择的只是对具体应用最合适的收集器。

**-XX:+PrintCommandLineFlags:查看命令行相关参数（包含使用的垃圾收集器）**

**使用命令行指令：jinfo-flag相关垃圾回收器参数进程ID**





##### **Serial回收器：串行回收**

- Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。

- Serial收集器作为HotSpot中Client模武下的默认新生代垃圾收集器。

- ==Serial收集器采用复制算法、串行回收和"stop-the-World"机制的方式执行内存回收。==

- 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。==Serial old收集器同样也采用了串行回收和"Stop the World"机制，只不过内存回收算法使用的是标记-压缩算法。==

- - Serial old是运行在client模式下默认的老年代的垃圾回收器

  - Serial old在server模式下主要有两个用途：

  - - ①与新生代的Parallel Scavenge配合使用
    - ②作为老年代CMS收集器的后备垃圾收集方案

![image-20211122135026472](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122135026472.png)

这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它==只会使用一个CPU或一条收集线程去完成垃圾收集工作==，更重要的是在它进行垃圾收集时，==必须暂停其他所有的工作线程==，直到它收集结束（Stop The World)。

- 优势：==简单而高效==（与其他收集器的单线程比）,对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

- - 运行在client模式下的虚拟机是个不错的选择。

- 在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB),可以在较短时间内完成垃圾收集（几十ms至一百多ms),只要不频繁发生，使用串行回收器是可以接受的。

- 在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。

- - 等价于新生代用Serial GC,且老年代用Serial 0ld GC

**总结：**

- 这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。
- 对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Javaweb应用程序中是不会采用串行垃圾收集器的。

##### **ParNew回收器：并行回收**

- 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。

- - Par是Parallel的缩写，New:只能处理的是新生代

- ParNew收集器除了采用==并行回收==的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是==采用复制算法、"Stop-the-World"==机制。

- ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器。

![image-20211122135315727](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122135315727.png)

- 对于新生代，回收次数频繁，使用并行方式高效。
- 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）

- 由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？

- - ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。
  - 但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Seria1收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。

- 因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作

- 在程序中，开发人员可以通过选项"-XX:+UseParNeWGC"手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。
- -XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。



##### **Parallel回收器：吞吐量优先**

- HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel scavenge收集器同样也采用了==复制算法、并行回收和"stop the World"机制。==

- 那么Parallel收集器的出现是否多此一举？

- - 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个==可控制的吞吐量==（Throughput),它也被称为吞吐量优先的垃圾收集器。
  - 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。

- 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，==主要适合在后台运算而不需要太多交互的任务==。因此，常见在服务器环境中使用。例如，==那些执行批量处理、订单处理、工资支付、科学计算的应用程序。==
- Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel old收集器，用来代替老年代的Serial old收集器。
- Parallel old收集器采用了==标记-压缩算法==，但同样也是基于==并行回收和"stop-the-World"机制。==

![image-20211122135719973](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122135719973.png)



- 在程序吞吐量优先的应用场景中，Parallel收集器和Parallel old收集器的组合，在Server模式下的内存回收性能很不错。
- 在Java8中，默认是此垃圾收集器。



###### **参数配置：**

- ==-XX:+UseParallelGC==手动指定年轻代使用Parallel并行收集器执行内存回收任务。

- ==-XX:+UseParallelOldGC==手动指定老年代都是使用并行回收收集器。

- - 分别适用于新生代和老年代。默认jdk8是开启的。
  - 上面两个参数，默认开启一个，另一个也会被开启。==（互相激活）==

- ==-XX:ParallelGCThreads==设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。

- - 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。
  - 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8]。

- ==-XX:MaxGCPauseMillis== 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。

- - 为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。
  - 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel,进行控制。
  - ==该参数使用需谨慎。==

- ==-XX:GCTimeRatio==垃圾收集时间占总时间的比例（=1/(N+1))。用于衡量吞吐量的大小。

- - 取值范围（0,100)。默认值99,也就是垃圾回收时间不超过1%。
  - 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。

- ==-XX:+UseAdaptiveSizePolijcy== 设置Parallel Scavenge收集器具有==自适应调节策略==

- - 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。
  - 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio)和停顿时间(MaxGCPauseMills),让虚拟机自己完成调优工作。

##### **CMS回收器：低延迟**

- 在JDK1.5时期，HotSpot推出了一款在==强交互应用==中几乎可认为有划时代意义的垃圾收集器：CMS(Concurrent-Mark-Sweep)收集器，==这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作==。

- CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。

- - ==目前很大一部分的Java应用集中在互联网站或者B/s系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验==。CMS收集器就非常符合这类应用的需求。

- CMs的垃圾收集算法采用==标记-清除==算法，并且也会"stop-the-world"

- 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。
- 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。



![image-20211122140224776](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122140224776.png)

###### CMS工作流程

CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。

- 初始标记（Initial-Mark)阶段：在这个阶段中，程序中所有的工作线程都将会因为"Stop-the-World"机制而出现短暂的暂停，这个阶段的主要任务==仅仅只是标记出GC Roots能直接关联到的对象==。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的==速度非常快。==
- 并发标记（Concurrent-Mark)阶段：从GC Roots的==直接关联对象开始遍历整个对象图的过程==，这个过程==耗时较长==但是==不需要停顿用户线程==，可以与垃圾收集线程一起并发运行。

- 重新标记（Remark)阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了==修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录==，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。
- 并发清除（Concurrent-Sweep)阶段：此阶段==清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。==由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的







- 尽管CMS收集器采用的是并发回收（非独占式）,但是在其==初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制==暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。
- ==由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的==。
- 另外，由于在垃圾收集阶段用户线程没有中断，==所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用==。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当==堆内存使用率达到某一阀值时，便开始进行回收==，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“==Concurrent Mode Failure=="失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了

* CMS收集器的垃圾收集算法采用的是==标记一清除算法==，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些==内存碎片==。那么CMs在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer)技术，而只能够选择空闲列表（Free List)执行内存分配



有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？ 

答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”这种场景下使用



###### **CMS的优点：**

- 并发收集
- 低延迟



###### **CMS的弊端：**

- ==会产生内存碎片==，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。
- ==CMs收集器对CPU资源非常敏感==。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
- ==CMs收集器无法处理浮动垃圾==。可能出现“Concurrent Mode Failure"失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么==在并发标记阶段如果产生新的垃圾对象，CMs将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，==从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

###### **参数设置**

- ==-XX:+UseConcMarkSweepGC==手动指定使用CMS收集器执行内存回收任务。

- - 开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew(Young区用）+CMS(Old区用）+Serial old的组合。

- ==-XX:CMSlnitiatingoccupanyFraction==设置堆内存使用率的國值，一旦达到该阙值，便开始进行回收。

- - JDK5及以前版本的默认值为68,即当老年代的空间使用率达到68号时，会执行一次CMS回收。==JDK6及以上版本默认值为92%==
  - 如果内存增长缓慢，则可以设置一个稍大的值，大的阙值可以有效降低CMs的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阙值，以避免频繁触发老年代串行收集器。因此==通过该选项便可以有效降低FullGC的执行次数。==

- ==-XX:+UseCMSCompactAtFulCollection==用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。

- ==-XX:CMSFullGCsBeforeCompaction==设置在执行多少次Full GC后对内存空间进行压缩整理。

- ==-XX:ParallelCMSThreads==设置CMS的线程数量。

- - CMS默认启动的线程数是（Paralle1GCThreads+3)/4,ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到cMs收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。



##### **G1回收器：区域化分代式**

既然我们已经有了前面几个强大的GC,为什么还要发布Garbage First(G1)GC?

- 原因就在于应用程序所应对的==业务越来越庞大、复杂，用户越来越多==，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1(Garbage-First)垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。

  =与此同时，为了适应现在==不断扩大的内存和不断增加的处理器数量==，进一步降低暂停时间（pause time),同时兼顾良好的吞吐量。

- ==官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。==





为什么名字叫做Garbage First(G1)呢？

- 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region)(物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。
- G1GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值）,在后台维护一个优先列表，==每次根据允许的收集时间，优先回收价值最大的Region==
- 由于这种方式的侧重点在于回收垃圾最大量的区间（Region),所以我们给G1一个名字：垃圾优先（Garbage First)。

- G1(Garbage-First)是一款面向服务端应用的垃圾收集器，==主要针对配备多核CPU及大容量内存的机器==，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。
- 在JDK1.7版本正式启用，移除了Experimental的标识，==是JDK9以后的默认垃圾回收器==，取代了CMS回收器以及Parallel+Parallel Old组合。被oracle官方称为“==全功能的垃圾收集器==”。
- 与此同时，CMS已经在JDK9中被标记为废弃（deprecated)。在jdk8中还不是默认的垃圾回收器，需要使用-XX:+UseG1GC来启用。



###### **优势**

与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：

- ==并行与并发==

- - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
  - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

- ==分代收集==

- - 从分代上看，==G1依然属于分代型垃圾回收器==，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
  - 将==堆空间分为若干个区域（Region),这些区域中包含了逻辑上的年轻代和老年代==
  - 和之前的各类回收器不同，它同时==兼顾年轻代和老年代==。对比其他回收器，或者工作在年轻代，或者工作在老年代；

- ==空间整合==

- - CMS:“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理
  - G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。==Region之间是复制算法==，但整体上实际可看作是==标记-压缩（Mark-Compact)算法==，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

- ==可预测的停顿时间模型（即：软实时soft real-time)==

- - 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
  - 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。
  - G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值）,在后台维护一个优先列表，==每次根据允许的收集时间，优先回收价值最大的Region==。保证了G1收集器在有限的时间内可以==获取尽可能高的收集效率==
  - 相比于CMSGC,G1未必能做到cMs在最好情况下的延时停顿，但是最差情况要好很多。



###### **缺点**

- 相较于CMS,G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint)还是程序运行时的额外执行负载（Overload)都要比CMS要高。
- 从经验上来说，在小内存应用上CMS的表现大概率会优于G1,而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。





###### 参数设置

- ==-XX:+UseG1GC==手动指定使用G1收集器执行内存回收任务。
- ==-XX:G1HeapRegionSize== 设置每个Region的大小。值是2的帚，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。
- ==-XX:MaxGCPauseMillis==设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms
- ==-XX:ParallelGCThread==设置STW工作线程数的值。最多设置为8
- ==-XX:ConcGCThreads== 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads)的1/4左右。
- ==-XX:InitiatingHeapOccupancyPercent==设置触发并发GC周期的Java堆占用率阀值。超过此值，就触发GC。默认值是45。





###### **常见操作步骤**

G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：

第一步：开启G1垃圾收集器

第二步：设置堆的最大内存

第三步：设置最大的停顿时间

G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC,在不同的条件下被触发。



###### **适用场景**

- 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）

- 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；

- 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；(G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。

- 用来替换掉JDK1.5中的CMS收集器；

- - 在下面的情况时，使用G1可能比CMS好：
  - ①超过50%的Java堆被活动数据占用；
  - ②对象分配频率或年代提升频率变化很大；
  - ③GC停顿时间过长（长于0.5至1秒）。

- HotSpot 垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。



###### **Region**

- 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幕，即1MB,2MB,4MB,8MB,16MB,32MB。可以通过-XX:G1HeapRegionSize设定。==所有的Region大小相同，且在JVM生命周期内不会被改变。==
- 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。

![image-20211122142536662](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122142536662.png)

- 一个region有可能属于Eden,Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，表示属于o1d内存区域。图中空白的表示未使用的内存空间。
- G1 垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region,就放到H。



**设置H的原因：**

对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。==如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。==为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。



###### **G1 GC的垃圾回收过程主要包括如下三个环节**：

- 年轻代GC(Young GC)
- 老年代并发标记过程（Concurrent Marking)
- 混合回收（Mixed GC)
- (如果需要，单线程、独占式、高强度的FullGC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）

![image-20211122142703927](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122142703927.png)

顺时针，young gc->young gc+concurrent mark->Mixed GC顺序，进行垃圾回收。



- 应用程序分配内存，==当年轻代的Eden区用尽时开始年轻代回收过程==；G1的年轻代收集阶段是一个==并行==的==独占式==收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后==从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。==
- 当堆内存使用达到一定值（默认45%)时，开始老年代并发标记过程。
- 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，==G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。==同时，这个老年代Region是和年轻代一起被回收的。
- 举个例子：一个Web服务器，Java进程最大堆内存为4G,每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45号，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。



###### **G1回收器垃圾回收过程：Remembered Set**

- 一个对象被不同区域引用的问题
- 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？
- 在其他的分代收集器，也存在这样的问题（而G1更突出）
- 回收新生代也不得不同时扫描老年代？
- 这样的话会降低Minor GC的效率；

**解决方法**：

- 无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：
- ==每个Region都有一个对应的Remembered Set;==
- 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；
- 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器：检查老年代对象是否引用了新生代对象）;
- 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；
- 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set;就可以保证不进行全局扫描，也不会有遗漏。

![image-20211122143138970](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122143138970.png)

###### **G1回收过程一年轻代GC**

- JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。
- ==年轻代垃圾回收只会回收Eden区和Survivor区==。
- 首先G1停止应用程序的执行（Stop-The-World),G1创建回收集(Collection Set),回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段

![image-20211122143331688](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122143331688.png)



然后开始如下回收过程：

第一阶段，==扫描根==。

根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。

第二阶段，==更新RSet==。

处理dirty card queue(见备注）中的card,更新RSet。此阶段完成后，==RSet可以准确的反映老年代对所在的内存分段中对象的引用==

第三阶段，==处理RSet。==

识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。

第四阶段，==复制对象。==

此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段Survivor区内存段中存活的对象如果年龄未达阀值，年龄会加1,达到阀值会被会被复制到old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。

第五阶段，==处理引用。==

处理Soft,Weak,Phantom,Final,JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。



对于应用程序的引用赋值语句object.field=object,JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet,保证RSet实时准确的反映引用关系。

那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步,开销会很大，使用队列性能会好很多。



###### **G1回收过程二：并发标记过程**

1. ==初始标记阶段==：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。

2. ==根区域扫描==（Root Region Scanning):G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。

3. ==并发标记==（Concurrent Marking):在整个堆中进行并发标记（和应用程序并发执行）,此过程可能被young GC中断。在并发标记阶段，==若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收==。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。

4. ==再次标记==（Remark):由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning(SATB)。

5. ==独占清理==（cleanup,STW):计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。

   这个阶段并不会实际上去做垃圾的收集

6. ==并发清理阶段==：识别并清理完全空闲的区域。



###### **G1回收过程三：混合回收**

当越来越多的对象晋升到老年代oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC,该算法并不是一个oldGC,除了回收整个Young Region,还会回收一部分的old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些oldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。



- 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。
- 混合回收的回收集（Collection Set)包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。
- 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阙值会决定内存分段是否被回收，-XX:G1MixedGCLiveThresholdPercent,默认为65%,意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。
- 混合回收并不一定要进行8次。有一个阀值-XX:G1HeapWastePercent,默认值为10%,意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%,则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。





###### **G1回收可选的过程四：Full GC**

G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会==停止应用程序的执行（Stop-The-world)==,使用==单线程==的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。

要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如==堆内存太小==，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc,这种情况可以通过增大内存解决。

导致G1Full GC的原因可能有两个：

1. Evacuation的时候没有足够的to-space来存放晋升的对象；

2. 并发处理过程完成之前空间耗尽。



**补充**

从Oracle官方透露出来的信息可获知，回收阶段（Evacuation)其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region,停顿时间是用户可控制的，所以并不迫切去实现，而==选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC)中==。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。



###### **G1回收器优化建议**

- 年轻代大小

- - 避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小
  - 固定年轻代的大小会覆盖暂停时间目标

- 暂停时间目标不要太过严苛

- - G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间
  - 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。



#### **垃圾回收器总结**



截止JDK1.8,一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。

![image-20211122144643694](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122144643694.png)

GC发展阶段：

Serial=>Parallel(并行）=>CMS(并发）=>G1=> ZGC

不同厂商、不同版本的虚拟机实现差别很大。HotSpot虚拟机在JDK7/8后所有收集器及组合（连线）,如下图：

![image-20211122134452834](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122134452834.png)

1. 两个收集器间有连线，表明它们可以搭配使用：

   Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial old、 Parallel Scavenge/Parallel old、G1;

2. 其中Serial old作为CMS出现"Concurrent Mode Failure"失败的后备预案。

3. (红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为Deprecated(JEP 173),并在JDK 91中完全取消了这些组合的支持（JEP214),即：移除。

4. (绿色虚线）JDK 14中：弃用ParallelScavenge和Serialold GC组合(JEP366)

5. (青色虚线）JDK 14中：删除CMS垃圾回收器（JEP 363)



Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。

怎么选择垃圾收集器？

优先调整堆的大小让JVM自适应完成。

如果内存小于100M,使用串行收集器

如果是单核、单机程序，并且没有停顿时间的要求，串行收集器

如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择

如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用）,使用并发收集器

官方推荐G1,性能高。==现在互联网的项目，基本都是使用G1。==





最小化地使用内存和并行开销，请选Serial GC;

最大化应用程序的吞吐量，请选Parallel GC;

最小化GC的中断或停顿时间，请选CMS GC。

- JDK9新特性：CMS被标记为Deprecate了（JEP291)

- - 如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。

- JDK14新特性：删除CMS垃圾回收器（JEP363)

- - 移除了CMS垃圾收集器，如果在JDK14中使用-XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM



最后需要明确一个观点：

1. 没有最好的收集器，更没有万能的收集；

2. 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器

对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。

这里较通用、基础性的部分如下：

垃圾收集的算法有哪些？如何判断一个对象是否可以回收？

垃圾收集器工作的基本流程。

另外，大家需要多关注垃圾回收器这一章的各种常用的参数。

#### **垃圾回收器的新发展**

GC仍然处于飞速发展之中，目前的默认选项==G1 GC在不断的进行改进==，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Fu11 GC实现。

即使是Serial GC,虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，==在Serverless等新的应用场景下，Serial GC找到了新的舞台。==



比较不幸的是CMS GC,因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除。



JEP318:Epsilon: A No-Op GarbageCollector(Epsilon 垃圾回收器，"No-Op(无操作）"回收器）http://openjdk.java.net/jeps/318

JEP333:ZGC:A Scalable Low-LatencyGarbage Collector(Experimental)(ZGC:可伸缩的低延迟垃圾回收器，处于实验性阶段）



##### **ZGC(JDK11出现）和Shenandoah(Open JDK12)。**



主打特点：低停顿时间

###### **Shenandoah**

- Shenandoah,无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的HotSpot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。
- Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。
- Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB,99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。

- 停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。
- 而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。

**总结：**

- Shenandoah GC的弱项：高运行负担下的吞吐量下降
- Shenandoah GC的强项：低延迟时间。
- Shenandoah GC的工作过程大致分为九个阶段，这里就不再赞述。在之前Java12新特性视频里有过介绍。



###### **令人震惊、革命性的ZGC**

https://docs.oracle.com/en/java/javase/12/gctuning/

- ZGC与Shenandoah目标高度相似，==在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。==
- 《深入理解Java虚拟机》一书中这样定义ZGC:ZGC收集器是一款基于Region内存布局的，(暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现==可并发的标记-压缩算法的==，以==低延迟为首要目标==的一款垃圾收集器。
- ZGC的工作过程可以分为4个阶段：==并发标记-并发预备重分配-并发重分配-并发重映射等。==
- ZGC几乎在所有地方并发执行的，除了==初始标记的是STW==的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。



在ZGC的强项停顿时间测试上，它毫不留情的将Paralle、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、99%停顿、99.9%停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。

==未来将在服务端、大内存、低延迟应用的首选垃圾收集器。==

现在mac或Windows上也能使用ZGC了，示例如下：

==-XX:+UnlockExperimentalVMOptions-XX:+UseZGC==

当然，其他厂商也提供了各种独具一格的GC实现，例如比较有名的低延迟GC,Zing (https://www.infoq.com/articles/azul_gc_in_detail),有兴趣可以参考提供的链接。



### **GC日志分析**

```shell
内存分配与垃圾回收的参数列表
-XX:+PrintGC		       输出GC日志。类似：-verbose:gc
-XX:+PrintGCDetails      输出GC的详细日志
-XX:+PrintGCTimeStamps   输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps   输出GC的时间戳（以日期的形式，如2013-05-04T21:53:59.234+0800)
-XX:+PrintHeapAtGC	在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log	日志文件的输出路径
```

![image-20211122145939447](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122145939447.png)

![image-20211122145954892](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122145954892.png)

![image-20211122150008946](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122150008946.png)

**日志补充说明：**

- "[GC"和"[Full GC"说明了这次垃圾收集的停顿类型，如果有"Full"则说明GC发生了"stop The World"
- 使用Serial收集器在新生代的名字是Default New Generation,因此显示的是"[DefNew"
- 使用ParNew收集器在新生代的名字会变成"[ParNew",意思是"Parallel New Generation'
- 使用Parallel Scavenge收集器在新生代的名字是"[PSYoungGen"
- 老年代的收集和新生代道理一样，名字也是收集器决定的
- 使用G1收集器的话，会显示为"garbage-first heap"

- Allocation Failure

  表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。

- [PSYoungGen:5986K->696K(8704K)]5986K-704K(9216K)

  中括号内：GC回收前年轻代大小，回收后大小，(年轻代总大小）

  括号外：GC回收前年轻代和老年代大小，回收后大小，(年轻代和老年代总大小）

- user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过real时间

![image-20211122150424776](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122150424776.png)



![image-20211122150442244](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211122150442244.png)



#### 工具

常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewerHpjmeter、garbagecat等。























## 工具&调优

**无监控、不调优！**

### 命令行工具

#### jps 虚拟机进程状况工具

**(Java Process Status) **

显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息）,可用于查询正在运行的虚拟机进程。

说明：对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的。

```shell
jps [options] [hostid]
jps -q  只看id
jps -l  查看全类名
jps -m  输出虚拟机进程启动时传递给主类main()的参数
jps -v  查看jvm参数
```

说明：以上参数可以综合使用。



补充：

如果某 Java 进程关闭了默认开启的UsePerfData参数（即使用参数-XX:-UsePerfData),那么jps命令（以及下面介绍的jstat)将无法探知该Java 进程。



RMI注册表中注册的主机名。

如果想要远程监控主机上的 java 程序，需要安装 jstatd。

对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到IP地址欺诈攻击。

如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行jstatd服务器，而是在本地使用jstat和jps工具。



#### jstat 虚拟机统计信息监视工具

jstat(JVM Statistics Monitoring Tool):用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。

在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测**垃圾回收问题以及内存泄漏问题**。

```shell
#它的基本使用语法为：
jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
#查看命令相关参数：
jstat -h 或 jstat -help
```

**选项option可以由以下值构成。**

- 类装载相关的：

- - **-class**:显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等

- ·垃圾回收相关的：

- - **-gc**:显示与GC相关的堆信息。包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。

  - - CCSC是压缩类空间的大小
    - CCSU是压缩类空间已使用的大小
    - YGC是指从应用程序启动到采样时young gc次数

- - - YGCT是指从应用程序启动到采样时young gc消耗的时间（秒）
    - FGC是指从应用程序启动到采样时full gc次数
    - FGCT是指从应用程序启动到采样时full gc消耗的时间（秒）
    - GCT是指从应用程序启动到采样时qc的总时间

- - **-gccapacity**:显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。
  - **-gcutil**:显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。
  - -**gccause**:与-gcuti1功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因。
  - -**gcnew**:显示新生代GC状况
  - -**gcnewcapacity**:显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间
  - -**gcold**:显示老年代GC状况
  - -**gcoldcapacity**:显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间
  - -**gcpermcapacity**:显示永久代使用到的最大、最小空间。

- JIT相关的：

- - -**compiler**:显示JIT编译器编译过的方法、耗时等信息
  - -**printcompilation**:输出已经被JIT编译的方法

**interval参数**

​	用于指定输出统计数据的周期，单位为毫秒。即：查询间隔

**count参数**

​	用于指定查询的总次

**-t参数**

可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒

我们可以比较 Java 进程的启动时间以及总 GC 时间（GCT列）,或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例。

如果该比例超过20%,则说明目前堆的压力较大；如果该比例超过90%,则说明堆里几乎没有可用空间，随时都可能抛出00M异常。

**-h参数**

 可以在周期性数据输出时，输出多少行数据后输出一个表头信息



**jstat还可以用来判断是否出现内存泄漏。**

第1步：

在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中OUI列（即已占用的老年代内存）的最小值。

第2步：

然后，我们每隔一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上涨趋势，则说明该Java程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。



#### **jinfo 配置信息工具**

实时查看和修改JVM配置参数

```shell
jinfo [ options ] pid
no option 输出全部的参数和系统属性
-flag name 输出对应名称的参数
-flag name=value 设定对应名称的参数
-flags 查看曾经赋过值的一些参数
-sysprops 输出系统属性  可以查看由System.getProperties()取得的参数
-flag [+-]name 开启或者关闭对应名称的参数
只有被标记为manageable的参数才可以被动态修改
修改即时生效
#可以查看被标记为manageable的参数
java -XX:+PrintFlagsFinal -version | grep manageable

java-XX:+PrintFlagslnitial 查看所有JVM参数启动的初始值
java-XX:+PrintFlagsFinal   查看所有JVM参数的最终值
java-XX:+PrintCommandLineFlags  查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值
```

#### **jmap 内存映像工具**

**导出内存映像文件&内存使用情况**

jmap(JVM Memory Map):作用一方面是获取dump文件（堆转储快照文件，二进制文件）,它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息。还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。

开发人员可以在控制台中输入命令“jmap-help”查阅jmap工具的具体使用方式和一些标准选项配置。

```shell
jmap [option] <pid>
jmap [option] <executable <core>
jmap [option] [server_id@]<remote server IP or hostname>

-dump
生成Java堆转储快照：dump文件  特别的：-dump:live只保存堆中的存活对象
-heap
输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等
-histo
输出堆中对象的统计信息，包括类、实例数量和合计容量-histo:live只统计堆中的存活对象
-permstat
以ClassLoader为统计口径输出永久代的内存状态信息 仅linux/solaris平台有效
-finalizerinfo
显示在F-Queue中等待Finalizer线程执行finalize方法的对象仅linux/solaris平台有效
-F
当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件仅linux/solaris平台有效
-h|-helpjmap工具使用的帮助命令
-J<flag>传递参数给jmap启动的jvm
```

其他获取dump文件方法

```shell
-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件，
-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件，
在Linux系统下通过Kill-3命令发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转储快照。
```

##### **使用1:导出内存映像文件**

```shell
手动的方式
jmap-dump:format=b,file=<filename.hprof><pid>
jmap-dump:live,format=b,file=<filename.hprof><pid>
自动的方式
-XX:+HeapDumpOnOutOfMemoryError  在程序发生OOM时，导出应用程序的当前堆快照。
-XX:HeapDumpPath=<filename.hprof>   可以指定堆快照的保存位置。
```

Heap Dump又叫做堆存储文件，指一个Java进程在某个时间点的内存快照。Heap Dump在触发内存快照的时候会保存此刻的信息如下：

·All Objects

Class, fields, primitive values and references

·All Classes

ClassLoader, name, super class, static fields

·Garbage Collection Roots

Objects defined to be reachable by the JVM

· Thread Stacks and Local Variables

The call-stacks of threads at the moment of the snapshot, and per-frame

information about local objects



说明：

1.通常在写Heap Dump文件前会触发一次Full GC,所以heap dump文件里保存的都是Full GC后留下的对象信息。

2.由于生成dump文件比较耗时，因此大家需要耐心等待，尤其是大内存镜像生成dump文件则需要耗费更长的时间来完成。



##### **使用2:显示堆内存相关信息**

```shell
-jmap -heap pid
-jmap -histo pid
```



**小结**

由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。

举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live选项将无法探知到这些对象。

另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。

与前面讲的jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中,而jstat只需直接读取即可。

#### **jhat 堆分析工具**

jhat ( JVM Heap Analysis Tool )

jhat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）。

使用了jhat命令，就启动了一个http服务，端口是7000,即http://localhost:7000/,

就可以在浏览器里分析。

说明：jhat命令在JDK9、JDK10中已经被删除，官方建议用VisualVM代替。

```shell
-stack false|true  关闭|打开对象分配调用栈跟跃
-refs false|true    关闭|打开对象引用跟踪
-port port-number    设置jhat HTTP Server的端口号，默认7000
-exclude exclude-file  执行对象查询时需要排除的数据成
-baseline exclude-file  指定一个基准堆转储
-debug int      设置debug级别
-version      启动后显示版本信息就退出
-J<flag>       传入启动参数，比如-J-Xmx512m
```

#### **jstack 堆栈跟踪工具**

jstack(JVM Stack Trace):用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。

生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用jstack显示各个线程调用的堆栈情况。

https://docs.oracle.com/en/java/javase/11/tools/jstack.html

在thread dump中，要留意下面几种状态

- ==死锁，Deadlock(重点关注）==
- ==等待资源，Waiting on condition(重点关注）==
- ==等待获取监视器，Waiting on monitor entry(重点关注）==
- ==阻塞，Blocked(重点关注）==
- ·执行中，Runnable
- ·暂停，Suspended

```shell
jstack [ option ] vmid

-F  当正常输出的请求不被响应时，强制输出线程堆栈
-l  除堆栈外，显示关于锁的附加信息
-m  如果调用到本地方法的话，可以显示C/C++的堆栈
-h  帮助操作
```

```java
//java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码完成jstack的大部分功能
new Thread(() -> {
    final Map<Thread, StackTraceElement[]> allStackTraces = Thread.getAllStackTraces();//追踪线程

    final Set<Map.Entry<Thread, StackTraceElement[]>> entries = allStackTraces.entrySet();
    for (Map.Entry<Thread, StackTraceElement[]> entry : entries) {
        final Thread key = entry.getKey();
        final StackTraceElement[] value = entry.getValue();
        System.out.println(key.getName());
        for (StackTraceElement stackTraceElement : value) {
            System.out.println(stackTraceElement.toString());
        }
    }
}, "").start();
```

#### **jcmd:多功能命令行**

在JDK 1.7以后，新增了一个命令行工具jcmd。

它是一个多功能的工具，可以用来实现前面除了jstat之外所有命令的功能。比如：[用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等。

官方帮助文档：

https://docs.oracle.com/en/java/javase/11/tools/jcmd.html

jcmd拥有jmap的大部分功能，并且在Oracle的官方网站上也推荐使用jcmd命令代jmap命令

```shell
jcmd-l    列出所有的JVM进程
jcmd pid help  针对指定的进程，列出支持的所有命令
jcmd pid 具体命令    显示指定进程的指令命令的数据
```

#### **jstatd:远程主机信息收集**

之前的指令只涉及到监控本机的Java应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如jps、jstat)。为了启用远程监控，则需要配合使用jstatd工具。

命令jstatd是一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd服务器将本机的Java应用程序信息传递到远程计算机。

### GUI工具

**jdk自带工具**

- jconsole:JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等   位置：jdk\bin\jconsole.exe

- Visual VM:Visual VM是一个工具，它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。  位置：jdk\bin\jvisualvm.exe

- JMC:Java Mission Control,内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据。

第三方工具

- MAT:MAT(Memory Analyzer Tool)是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗Eclipse的插件形式
- JProfiler:商业软件，需要付费。功能强大。与VisualVM类似
- Arthas:Alibaba开源的Java诊断工具。深受开发者喜爱。
- Btrace:Java运行时追踪工具。可以在不停机的情况下，跟踪指定的方法调用、构造函数调用和系统内存等信息。



#### **jconsole**

·从Java5开始，在JDK中自带的java监控和管理控制台。

·用于对JVM中内存、线程和类等的监控，是一个基于JMX(java management extensions)的GUI性能监控工具。

Local

使用JConsole连接一个正在本地系统运行的JVM,并且执行程序的和运行JConsole的需要是同一个用户。JConsole使用文件系统的授权通过RMI连接器连接到平台的MBean服务器上。这种从本地连接的监控能力只有Sun的JDK具有。

Remote

使用下面的URL通过RMI连接器连接到一个JMX代理，service:jmx:rmi:///jndi//hostName:portNum/jmxrmi。JConsole为建立连接，需要在环境变量中设置mx.remote.credentials来指定用户名和密码，从而进行授权。

Advanced

使用一个特殊的URL连接JMX代理。一般情况使用自己定制的连接器而不是RMI提供的连接器来连接JMX代理，或者是一个使用JDK1.4的实现了JMX和JMX Rmote的应用。





#### **Visual VM**

是一个功能强大的多合一故障诊断和性能监控的可视化工具。

它集成了多个JDK命令行工具，使用Visual VM可用于显示虚拟机进程及进程的配置和环境信息(jps,jinfo),监视应用程序的CPU、GC、堆、方法区及线程的信息（jstat、jstack)等，甚至代替JConsole。

在JDK 6 Update 7以后，Visual VM便作为JDK的一部分发布（VisualVM 在JDK/bin目录下）即：它完全免费。

此外，Visual VM也可以作为独立的软件安装：

Visual VM的一大特点是支持插件扩展，并且插件安装非常方便。我们既可以通过离线下载插件文件*.nbm,然后在Plugin对话框的已下载页面下，添加已下载的插件。也可以在可用插件页面下，

在线安装插件。（这里建议安装上：VisualGC)

插件地址：https://visualvm.github.io/pluginscenters.html

IDEA安装VisualVM Launcher插件



远程连接

1-确定远程服务器的ip地址

2-添加JMX(通过JMX技术具体监控远端服务器哪个Java进程

3-修改bin/catalina.sh文件，连接远程的tomcat

4-在.../conf中添加jmxremote.access和jmxremote.password文件

5-将服务器地址改为公网ip地址

6-设置阿里云安全策略和防火墙策略

7-启动tomcat,查看tomcat启动日志和端口监听

8-JMX中输入端口号、用户名、密码登录



主要功能

1. 生成/读取堆内存快照

2. 查看JVM参数和系统属性

3. 查看运行中的虚拟机进程

4. 生成/读取线程快照

5. 程序资源的实时监控

6. 其他功能

   ​	JMX代理连接	

   ​	远程环境监控

   ​	CPU分析和内存分析



#### **eclipse MAT**

MAT(Memory Analyzer Tool)工具是一款功能强大的Java堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。

MAT是基于Eclipse开发的，不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便。大家可以在https://www.eclipse.org/mat/downloads.php下载并使用MAT。



MAT可以分析heap dump文件。在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息。一般说来，这些内存信息包含：

- 所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。
- ·所有的类信息，包括classloader、类名称、父类、静态变量等
- ·GCRoot到所有的这些对象的引用路径
- ·线程信息，包括线程的调用栈及此线程的线程局部变量（TLS)

**说明1:缺点：**

MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如Sun,HP,SAP所采用的HPRQF二进制堆存储文件，以及IBM的PHD堆存储文件等都能被很好的解析。

**说明2:**

最吸引人的还是能够快速为开发人员生成==内存泄漏报表==，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。



**获取dump文件**

方法一：通过前一章介绍的jmap工具生成，可以生成任意一个java进程的dump文件；

方法二：通过配置JVM参数生成。

* 选项"-XX:tHeapDumpOnOutofMemoryError"或"-XX:+HeapDumpBeforeFullGC"

* 选项"-XX:HeapDumpPath"所代表的含义就是当程序出现OutofMemory时，将会在相应的目录下生成一份dump文件。如果不指定选项“-XX:HeapDumpPath”则在当前目录下生成dump文件。

  对比：考虑到生产环境中几乎不可能在线对其进行分析，大都是采用离线分析，因此使用jmap+MAT工具是最常见的组合。

方法三：使用VisualVM可以导出堆dump文件

方法四：使用MAT既可以打开一个已有的堆快照，也可以通过MAT直接从活动Java程序中导出堆快照。该功能将借助jps列出当前正在运行的Java进程，以供选择并获取快照。



histogram

thread over view

获得对象相互引用的关系

浅堆与深堆

支配树



**浅堆（Shallow Heap)**是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会向8字节进行对齐。

以String为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节。（jdk7中）

这24字节为String对象的浅堆大小。它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节。



**保留集（Retained Set):**

对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身）,即对象A的保留集可以被认为是只能通过对象A被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象A所持有的对象的集合。



**深堆（Retained Heap):**

深堆是指对象的保留集中所有的对象的浅堆大小之和。

注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。



**补充：对象实际大小**

另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象==所能触及的所有对象的浅堆==大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，==但实际上，这个概念和垃圾回收无关。==

下图显示了一个简单的对象引用关系图，对象A引用了C和D,对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D,而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。

![image-20211119155350609](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211119155350609.png)

支配树（Dominator Tree)

支配树的概念源自图论。

MAT提供了一个称为支配树（Dominator Tree)的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，**所有指向对象B的路径都经过对象A,则认为**==对象A支配对象B==。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的==直接支配者==。支配树是基于对象间的引用图所建立的，它有以下基本性质： 

- 对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set),即深堆。
- ·如果对象A支配对象B,那么对象A的直接支配者也支配对象B。
- ·支配树的边与对象引用图的边不直接对应。

如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A,也可以经过B,因此对象C的直接支配者也是根对象。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D,因此，对象D是对象F的直接支配者。而到对象D的所有路径中，必然经过对象C,即使是从对象F到对象D的引用，从根节点出发，也是经过对象的，所以，对象D的直接支配者为对象C。

![image-20211119155643090](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211119155643090.png)

#### **JProfiler**

特点：

- 使用方便、界面操作友好（简单且强大）
- 对被分析的应用影响小（提供模板）

- ·CPU,Thread,Memory分析功能尤其强大
- ·支持对jdbc,noSq1,jsp,servlet,socket等进行分析
- ·支持多种模式（离线，在线）的分析
- ·支持监控本地、远程的JVM
- ·跨平台，拥有多种操作系统的安装版本



1-方法调用  对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法

2-内存分配  通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄漏问题，优化内存使用

3-线程和锁   JProfiler提供多种针对线程和锁的分析视图助您发现多线程问题

4-高级子系统   许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析



**数据采集方式**

Instrumentation重构模式

Sampling抽样模式



- Instrumentation:这是JProfiler全功能模式。在class加载之前，JProfier把相关功能代码写入到需要分析的class的bytecode中，对正在运行的jvm有一定影响。

- - ·优点：功能强大。在此设置中，调用堆栈信息是准确的。
  - ·缺点：若要分析的class较多，则对应用的性能影响较大，CPU开销可能很高（取决于Filter的控制）。因此使用此模式一般配合Filter使用，只对特定的类或包进行分析。

- · Sampling:类似于样本统计，每隔一定时间（5ms)将每个线程栈中方法栈中的信息统计出来。

- - ·优点：对CPU的开销非常低，对应用影响小（即使你不配置任何Filter)
  - ·缺点：一些数据/特性不能提供（例如：方法的调用次数、执行时间）

注：JProfiler本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为JProfiler的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是JProfiler的数据采集类型。



Live memory 内存剖析：class/class instance的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。

·所有对象All Objects

显示所有加载的类的列表和在堆上分配的实例数。只有Java 1.5(JVMTI)才会显示此视图。

·记录对象 Record Objects

查看特定时间段对象的分配，并记录分配的调用堆栈。

·分配访问树 Allocation Call Tree

显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的J2EE组件。

·分配热点 Allocation Hot Spots

显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对

于每个热点都可以显示它的跟踪记录树。

·类追踪器 Class Tracker

类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。



JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所

管理的方法以树状形式呈现。对线程剖析。

线程历史 Thread History

显示一个与线程活动和线程状态在一起的活动时间表。

线程监控ThreadMonitor

显示一个列表，包括所有的活动线程以及它们目前的活动状况。

线程转储 Thread Dumps

显示所有线程的堆栈跟踪。

线程分析主要关心三个方面：

1.web容器的线程最大数。比如：Tomcat的线程容量应该略大于最大并发数。

2.线程阻塞

3.线程死锁



**监控和锁 Monitors & Locks** 所有线程持有锁的情况以及锁的信息。

观察JVM的内部线程并查看状态：

- ·死锁探测图表 Current Locking Graph:显示JVM中的当前死锁图表。
- ·目前使用的监测器 Current Monitors:显示目前使用的监测器并且包括它们的关联线程。
- ·锁定历史图表Locking History Graph:显示记录在JVM中的锁定历史。
- ·历史检测记录Monitor History:显示重大的等待事件和阻塞事件的历史记录。
- ·监控器使用统计 Monitor Usage Statistics:显示分组监测，线程和监测类的统计监测数据





#### **Arthas**

Arthas(阿尔萨斯）是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启

动态跟踪Java代码；实时监控JVM状态。

Arthas 支持JDK 6+,支持Linux/Mac/Windows,采用命令行交互模式，同时提供丰富的Tab自动补全功能，进一步方便进行问题的定位和诊断。

当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：

- ·这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception?
- ·我改的代码为什么没有执行到？难道是我没commit?分支搞错了？
- ·遇到问题无法在线上 debug,难道只能通过加日志再重新发布吗？
- ·线上遇到某个用户的数据处理有问题，但线上同样无法 debug,线下无法重现！
- ·是否有一个全局视角来查看系统的运行状况？
- ·有什么办法可以监控到JVM的实时运行状态？
- ·怎么快速定位应用的热点，生成火焰图？



##### 安装启动

**安装方式一**：可以直接在Linux上通过命令下载

可以在官方 Github 上进行下载，如果速度较慢，可以尝试国内的码云 Gitee 下载。

·github下载

wget https://alibaba.github.io/arthas/arthas-boot.jar

·Gitee下载

wget https://arthas.gitee.io/arthas-boot.jar

**安装方式二**：

也可以在浏览器直接访问https://alibaba.github.io/arthas/arthas-boot.jar,等待下载成功后，上传到Linux服务器上。

**卸载：**

在Linux/Unix/Mac平台删除下面文件：

```shell
rm -rf ~/.arthas/
rm -rf ~/logs/arthas
```

Windows平台直接删除user home下面的.arthas和logs/arthas目录



**启动**

方式1:

```shell
java -jar arthas-boot.jar
# 选择进程（输入[]内编号（不是PID)回车）
[INFO] arthas-boot version:3.1.4
[INFO] Found existing java process, please choose one and hit RETURN.
[1]:11616 com.Arthas
[2]:8676
[3]:16200 org.jetbrains.jps.cmdline.Launcher
[4]:21032 org.jetbrains.idea.maven.server.RemoteMavenServer
```

方式2:运行时选择 Java 进程 PID

```shell
java-jar arthas-boot.jar [PID]
```

除了在命令行查看外，Arthas目前还支持WebConsole。在成功启动连接进程之后就已经自动动，可以直接访问http://127.0.0.1:8563/访问，页面上的操作模式和控制台完全一样。



使用quit\exit:退出当前客户端

使用stop\shutdown:关闭arthas服务端，并退出所有客户端



查看日志cat ~/logs/arthas/arthas.log

参看帮助 java-jar arthas-boot.jar -h



工程目录

```
arthas-agent:基于JavaAgent技术的代理
bin:一些启动脚本
arthas-boot:Java版本的一键安装启动脚本
arthas-client:telnet client代码
arthas-common:一些共用的工具类和枚举类
arthas-core:核心库，各种arthas命令的交互和实现
arthas-demo:示例代码
arthas-memorycompiler:内存编绎器代码，Fork from
https://github.com/skalogs/SkaETL/tree/master/compiler
arthas-packaging:maven打包相关的
arthas-site:arthas站点
arthas-spy:编织到目标类中的各个切面
static:静态资源
arthas-testcase:测试
```

##### **指令**

###### 基础指令

```shell
help--查看命令帮助信息
cat--打印文件内容，和linux里的cat命令类似
echo-打印参数，和linux里的echo命令类似
grep--匹配查找，和linux里的grep命令类似
tee--复制标准输入到标准输出和指定的文件，和linux里的tee命令类似
pwd--返回当前的工作目录，和linux命令类似
cls--清空当前屏幕区域
session--查看当前会话的信息
reset--重置增强类，将被Arthas增强过的类全部还原，Arthas服务端关闭时会重置所有增强过的类
version---输出当前目标Java进程所加载的Arthas版本号
history--打印命令历史
quit--退出当前Arthas客户端，其他Arthas客户端不受影响
stop--关闭Arthas服务端，所有Arthas客户端全部退出
keymap--Arthas快捷键列表及自定义快捷键
```

###### jvm相关

```shell
dashboard--当前系统的实时数据面板
thread--查看当前JVM的线程堆栈信息
jvm--查看当前JVM的信息
sysprop--查看和修改JVM的系统属性
sysenv_I查看JVM的环境变量
vmoption--查看和修改JVM里诊断相关的option
perfcounter--查看当前JVM的Perf Counter信息
logger--查看和修改logger
getstatic--查看类的静态属性
ognl--执行ognl表达式
mbean--查看Mbean的信息
heapdump--dump java heap,类似jmap命令的heap dump功能
```

###### **class/classloader 相关**

sc命令：查看JVM已加载的类信息

- ·https://arthas.aliyun.com/doc/sc

- ·常用参数：

  class-pattern类名表达式匹配

  -d输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。如果一个类被多个ClassLoader所加载，则会出现多次

  -E开启正则表达式匹配，默认为通配符匹配

  -f 输出当前类的成员变量信息（需要配合参数-d一起使用）

  -x 指定输出静态变量时属性的遍历深度，默认为0,即直接使用toString输出

- ·补充：

  1.class-pattern支持全限定名，如com.test.AAA,也支持com/test/AAA这样的格式,这样，我们从异常堆栈里面把类名拷贝过来的时候，不需要在手动把/替换为.了。

  2.sc默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开options disable-sub-class true开关

sm命令：查看已加载类的方法信息

- ·https://arthas.aliyun.com/doc/sm

- ·sm命令只能看到由当前类所声明（declaring)的方法，父类则无法看到。

- ·常用参数：

  class-pattern类名表达式匹配

  method-pattern方法名表达式匹配

  -d展示每个方法的详细信息

  -E开启正则表达式匹配，默认为通配符匹配



###### **jad**

在Arthas Console上，反编译出来的源码是带语法高亮的，阅读更方便, 当然，反编译出来的java代码可能会存在语法错误，但不影响你进行阅读理解

###### **mc命令**

Memory Compiler/内存编译器，编译.java文件生成.classhttps://arthas.aliyun.com/doc/mc

###### **redefine命令**

加载外部的.class文件，redefine jvm已加载的类。https://arthas.aliyun.com/doc/redefine 推荐使用 retransform命令

###### **classloader命令**

查看classloader的继承树，urls,类加载信息

- ·https://arthas.aliyun.com/doc/classloader
- ·了解当前系统中有多少类加载器，以及每个加载器加载的类数量，帮助您判断是否有类加载器泄漏。
- ·常用参数：

-t:查看ClassLoader的继承树

-1:按类加载实例查看统计信息

-c:用classloader对应的hashcode来查看对应的jar urls



###### monitor

**monitor**命令：方法执行监控

- 对匹配class-pattern/method-patterT的类、方法的调用进行监控。涉及方法的调用次数、执行时间、失败率等

- https://arthas.aliyun.com/doc/monitor

- monitor命令是一个非实时返回命令

- 常用参数：

  class-pattern类名表达式匹配

  method-pattern方法名表达式匹配

  -c统计周期，默认值为120秒



·监控项：

timestamp  时间戳

class  Java类

method  方法（构造方法、普通方法)



###### **watch命令**

方法执行数据观测



·https://arthas.aliyun.com/doc/watch

·让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看。

·常用参数：

class-pattern类名表达式匹配

method-pattern方法名表达式匹配

express 观察表达式

condition-express条件表达式

-b在方法调用之前观察（默认关闭）

-e在方法异常之后观察（默认关闭）

-s在方法返回之后观察（默认关闭）

-f在方法结束之后（正常返回和异常返回）观察（默认开启）

-x指定输出结果的属性遍历深度，默认为

\#cost 方法执行耗时

·说明：这里重点要说明的是观察表达式，观察表达式的构成主要由ognl表达式组成，

所以你可以这样写"{params,returnobj}",只要是一个合法的ognl表达式，都能被正常支持。

举例：watch全限定类名方法名returnObj



###### **trace命令**

**方法内部调用路径，并输出方法路径上的每个节点止耗时**

·https://arthas.aliyun.com/doc/trace

补充说明：

·trace命令能主动搜索class-pattern/method-pattern对应的方法调用路径，渲

染和统计整个调用链路上的所有性能开销和追踪调用链路。

·trace能方便的帮助你定位和发现因RT高而导致的性能问题缺陷，但其每次只能跟踪

一级方法的调用链路

·trace在执行的过程中本身是会有一定的性能开销，在统计的报告中并未像

JProfiler 一样预先减去其自身的统计开销。所以这统计出来有些许的不准，渲染路径

上调用的类、方法越多，性能偏差越大。但还是能让你看清一些事情的。

·参数说明

class-pattern类名表达式匹配

method-pattern方法名表达式匹配

condition-express条件表达式

-n 命令执行次数

\#cost方法执行耗时



###### *stack命令*

**输出当前方法被调用的调用路径**

·https://arthas.aliyun.com/doc/stack

·常用参数

class-pattern类名表达式匹配

method-pattern方法名表达式匹配

condition-express条件表达式

-n 执行次数限制

\#cost 方法执行耗时



###### tt命令

**方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时闻下调用进行观测。**

·https://arthas.aliyun.com/doc/tt

·TimeTunnel的缩写

·常用参数：

-t表明希望记录下类*Test的print方法的每次执行情况。

-n 3 指定你需要记录的次数，当达到记录次数时 Arthas 会主动中断七七命令的记录过

程，避免人工操作无法停止的情况。

-s 筛选指定方法的调用信息

-i参数后边跟着对应的INDEX编号查看到它的详细信息

-p重做一次调用通过--replay-times指定调用次数，通过--replay-interval 指定多次调用间隔（单位ms,默认1000ms)



#### **Java Mission Control**

Java Mission Control(简称JMC),Java官方提供的性能强劲的工具。是一个用于对Java应用程序进行管理、监视、概要分析和故障排除的工具套件。

它包含一个GUI客户端，以及众多用来收集Java虚拟机性能数据的插件，如JMX Console(能够访问用来存放虚拟机各个子系统运行数据的MXBeans),以及虚拟机内置的高效profiling 工具 Java Flight Recorder(JFR)。

JMC 的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小,完全可以开着JMC来做压测（唯一影响可能是fullgc多了）。



如果是远程服务器，使用前要开JMX。

-Dcom.sun.management.jmxremote.port=${YOUR PORT}

-Dcom.sun.management.jmxremote

-Dcom.sun.management.jmxremote.authenticate=false

-Dcom.sun.management.jmxremote.ssl=false

-Djava.rmi.server.hostname=${YOUR HOST/IP}

文件->连接->创建新连接，填入上面JMX参数的host和port



##### **Java Flight Recorder 取样分析**

Java Flight Recorder是JMC的其中一个组件。

Java Flight Recorder能够以极低的性能开销收集 Java 虚拟机的性能数据。

JFR的性能开销很小，赶默认配置下平均低于1%。与其他工具相比，JFR能够直接访问虚拟机内的数据，并且不会影响虚拟机的优化。因此，它非常适用于生产环境下满负荷运行的Java程序。

Java Flight Recorder和JDK Mission Control共同创建了一个完整的工具链。JDK Mission Control可对Java Flight Recorder连续收集低水平和详细的运行时信息进行高效详细的分析。



##### 事件类型

当启用时，JFR将记录运行过程中发生的一系列事件。其中包括Java层面的事件，如线程事件、

锁事件，以及Java虚拟机内部的事件，如新建对象、垃圾回收和即时编译事件。

按照发生时机以及持续时间来划分，JFR的事件共有四种类型，它们分别为以下四种。

1.瞬时事件（Instant Event),用户关心的提它们发生与否，例如异常、线程启动事件。

2.持续事件（Duration Event),用户关心的是它们的持续时间，例如垃圾回收事件。

3.计时事件（Timed Event),是时长超出指定阙值的持续事件。

4.取样事件（Sample Event),是周期性取样的事件。

取样事件的其中一个常见例子便是方法抽样（Method Sampling),即每隔一段时间统计各个线程的

栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点

方法。



##### 启动方式

###### 方式1:使用-XX:StartFlightRecording=参数

第一种是在运行目标 Java 程序时添加-XX:StartFlightRecording=参数。

比如：下面命令中，JFR将会在Java虚拟机启动5s后（对应delay=5s)收集数据，持续20s(对应duration=20s)。当收集完毕后，JFR会将收集得到的数据保存至指定的文件中（对应filename = myrecording . jfr )

```shell
java -XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecording.jfr,settings=profile MyAPP
```

由于JFR将持续收集数据，如果不加以限制，那么JFR可能会填满硬盘的所有空间。因此，我们有必要对这种模式下所收集的数据进行限制。比如：

```shell
java -XX:StartFlightRecording=maxage=10m,maxsize=100m,name=SomeLabel MyApp
```

###### 方式2:使用jcmd的JFR.*子命令

通过jcmd来让JFR开始收集数据、停止收集数据，或者保存所收集的数据，对应的子命令分别为JFR.start,JFR.stop,以及JFR.dump。

```shell
$ jcmd <PID> JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel
```

上述命令运行过后，目标进程中的JFR已经开始收集数据。此时，我们可以通过下述命令来导出己经收集到的数据：

```shell
$ jcmd <PID> JFR. dump name=SomeLabel filename=myrecording. jfr
```

最后，我们可以通过下述命令关闭目标进程中的JFR:

```shell
$ jcmd <PID> JFR. stop name=SomeLabel
```

###### 方式三:idea的JFR插件

![image-20211119162114386](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211119162114386.png)





##### Flame Graphs(火焰图）

在追求极致性能的场景下，了解你的程序运行过程中cpu在干什么很重要，火焰图就是一种非常直观的展示cpu在程序整个生命周期过程中时间分配的工具。
火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用栈中的CPU消耗瓶颈。
网上的关于java火焰图的讲解大部分来自于Brendan Gregg的博客：
http://www.brendangregg.com/flamegraphs.html

x轴横条宽度来度量时间指标，y轴代表线程栈的层次。



#### **TProfiler**

那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具TProfiler来定位这些性能代码，成功解决掉了GC过于频繁的性能瓶颈，并最终在上次优化的基础上将TPS再提升了4倍，即提升到100。

- TProfiler配置部署、远程操作、日志阅读都不太复杂，操作还是很简单的。但是其却是能够起到一针见血、立竿见影的效果，帮我们解决了GC过于频繁的性能瓶颈。

- **TProfiler最重要的特性就是能够统计出你指定时间段内JVM的top method,**这些topmethod极有可能就是造成你JVM性能瓶颈的元凶。这是其他大多数JVM调优工具所不具备的,包括JRockit Mission Control。JRokit首席开发者Marcus Hirt在其私人博客《Low Overhead Method Profiling with Java Mission Control》下的评论中曾明确指出JRMC并不支持TOP方法的统计。

·TProfiler的下载：

https://github.com/alibaba/TProfiler



#### **BTrace**

BTrace是SUN Kenai云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。先看一下BTrace的官方定义：

简洁明了，大意是一个Java平台的安全的动态追踪工具。可以用来动态地追踪一个运行的Java程序。

BTrace动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪”）。

Java运行时追踪工具

常见的动态追踪工具有BTrace、HouseMD(该项目已经停止开发）、Greys-Anatomy(国人开发，个人开发者）、Byteman(JBoss出品）,注意Java运行时追踪工具并不限于这几种，但是这几个是相对比较常用的。



#### **YourKit**

#### **JProbe**

#### **Spring Insight**



### OQL

对象查询语言



#### Select子句

在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列。Select子句中可以使用“*”，查看结果对象的引用实例（相当于outgoing references)。

```sql
SELECT * FROM java.util.Vector v
```

使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。

```sql
SELECT objects v.elementData FROM java.util.Vector v
SELECT OBJECTS s.value FROM java.lang.String s

--在Select子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。
SELECT AS RETAINED SET * FROM com . atguigu . mat . Student

--“DISTINCT”关键字用于在结果集中去除重复对象。
SELECT DISTINCT OBJECTS classof(s) FROM java. lang. String s
```

#### From子句

```sql
--From子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。
SELECT * FROM java.lang.String s

--下例使用正则表达式，限定搜索范围，输出所有com.atguigu包下所有类的实例
SELECT * FROM licom\.atguigu\..*"

--也可以直接使用类的地址进行搜索。使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型。
select * from 0x37a0b4d
```

#### Where 子句

```sql
--Where子句用于指定0QL的查询条件。OQL查询将只返回满足Where子句指定条件的对象。
--Where子句的格式与传统SQL极为相似。下例返回长度大于10的char数组。
SELECT * FROM char[] s WHERE s.@length>10 

--下例返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。
SELECT * FROM java.lang.String S WHERE toString ( s ) LIKE ".*java.* "

--下例返回所有value域不为null的字符串，使用“=”操作符。
SELECT * FROM java . lang . String s where s . value ! = null

--Where子句支持多个条件的AND、OR运算。下例返回数组长度大于15,并且深堆大于1000字节的所有Vector对象。
SELECT * FROM java.util.Vector V WHERE v.elementData.@length > 15 AND v.@retainedHeapSize>1000
```

OQL中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时格式如下：

```sql
[ <alias>. ] <field> . < field > . < field >


--其中alias为对象名称。
--访问java.io.File对象的path属性，并进一步访问path的value属性：
SELECT toString(f.path.value)FROM java.io.File f

--下例显示了String对象的内容、objectid和objectAddress。
SELECT s.toString(),s.@objectId,s.@objectAddress FROM
java.lang.String s

--下例显示java.util.Vector内部数组的长度。
SELECT v.elementData.@length FROM java.util.Vector v

--下例显示了所有的java.util.Vector对象及其子类型
select * from INSTANCEOF java.util.Vector
```



## JVM参数

Java提供了java.lang.management包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地和远程监控和管理运行的Java虚拟机。其中ManagementFactory这个类还是挺常用的。另外还有Runtime类也可以获取一些内存、CPU核数等相关的数据。通过这些api可以监控我们的应用服务器的堆内存使用情况，设置一些國值进行报警等处理。

### **类型一：标准参数选项**

比较稳定，特点以-开头

### **类型二：-X参数选项**

非标准化参数

特点功能还是比较稳定的。但官方说后续版本可能会变更

以-X开头



java -X 可看所有

**JVM的JIT编译模式相关的选项**

**-Xint   禁用JIT 最慢**

**-Xcomp   全编译再执行**

**-Xmixed    混合模式**

**-Xms  初始堆    =-XX:InitialHeapSize**

**-Xmx 最大堆   = -XX:MaxHeapSize**

**-Xss 栈     = -XX:ThreadStackSize**



### **类型三：-XX参数选项**

非标准化参数

使用的最多的参数类型

这类选项属于实验性，不稳定

以-XX开头



**-XX:+PrintFlagsFinal**

输出所有参数的名称和默认值

默认不包括Diagnostic和Experimental的参数

可以配合-XX:+UnlockDiagnosticVMOptions和-XX:UnlockExperimentalVMOptions使用



tomcat 运行war包

Linux系统下可以在tomcat/bin/catalina.sh中添加类似如下配置：

JAVA_OPTS="-Xms512M-Xmx1024M"

Windows系统下在catalina.bat中添加类似如下配置：

set "JAVA_OPTS=-Xms512M-Xmx1024M"



程序运行过程中

```shell
jinfo-flag<name>=<value><pid> #设置非Boolean类型参数
jinfo-flag[+/-]<name><pid> #设置Boolean类型参数
```

但是，并非所有参数都支持动态修改。参数只有被标记为manageable的flag可以被实时修改。其实，这个修改能力是极其有限的。

```shell
#可以查看被标记为manageable的参数
java -XX:+PrintFlagsFinal -version | grep manageable
```



### **常用参数**

#### **打印设置的XX选项及值**

```shell
-XX:+PrintCommandLineFlags #可以让在程序运行前打印出用户手动设置或者JVM自动设置的XX选项
-XX:+PrintFlagslnitial #表示打印出所有XX选项的默认值
-XX:+PrintFlagsFinal #表示打印出XX选项在运行程序时生效的值
-XX:+PrintVMOptions #打印JVM的参数
```

#### **栈**

```shell
-Xss128k   = -XXThreadStackSize=128k
```

#### 堆

```shell
-Xmx = -XX:MaxHeapSize
-Xms = -XX:InitialHeapSize
-Xmn2g   设置年轻代     官方推荐为堆的3/8
-XX:NewSize=1024m 设置年轻代初始值
-XX:MaxNewSize=1024m 设置年轻代最大值
-XX:SurvivorRatio=8  设置年轻代中Eden区与一个Survivor区的比值，默认为8
-XX:+UseAdaptiveSizePolicy  自动选择各区大小比例  默认开启
-XX:NewRatio=4  设置老年代与年轻代（包括1个Eden和2个Survivor区）的比值
-XX:PretenureSizeThreadshold=1024  大于此阈值的对象直接分配在老年代，单位为字节   只对Serial、ParNew收集器有效
-XX:MaxTenuringThreshold=15   默认值为15  新生代每次MinorGC后，还存活的对象年龄+1,当对象的年龄大于设置的这个值时就进入老年代
-XX:+PrintTenuringDistribution 让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布
-XX:TargetSurvivorRatio   表示MinorGC结束后Survivor区域中占用空间的期望比例
```

#### 永久代

```shell
-XX:PermSize=256m   设置永久代初始值为256M
-XX:MaxPermSize=256m  设置永久代最大值为256M
```

#### 元空间

```shell
-XX:MetaspaceSize  初始空间大小
-XX:MaxMetaspaceSize  最大空间，默认没有限制
-XX:+UseCompressedOops  压缩对象指针
-XX:+UseCompressedClassPointers  压缩类指针
-XX:CompressedClassspaceSize  设置Klass Metaspace的大小，默认1G
```

#### **直接内存**

```shell
-XX:MaxDirectMemorySize   指定DirectMemory容量，若未指定，则默认与Java堆最大值一样
```

#### **OutofMemory相关的选项**

```shell
-XX:+HeapDumpOnOutOfMemoryError 表示在内存出现OOM的时候，把Heap转存（Dump)到文件以便后续分析
-XX:+HeapDumpBeforeFullGC表示在出现FullGC之前，生成Heap转储文件
-XX:HeapDumpPath=<path> 指定heap转存文件的存储路径
-XX:OnOutOfMemoryError 指定一个可行性程序或者脚本的路径，当发生OOM的时候，去执行这个脚本
```

对OnOutOfMemoryError的运维处理

以部署在linux系统/opt/Server目录下的Server.jar为例

1.在run.sh启动脚本中添加jvm参数：

```shell
-XX:OnOutOfMemoryError=/opt/Server/restart.sh
```

2.restart.sh脚本

linux环境：

```shell
#!/bin/bash
pid=$(ps-ef|grep Server.jar|awk'{if($8=="java"){print $2}}')
kill -9 $pid
cd /opt/Server/;sh run.sh
```

Windows环境：

```cmd
echo off
wmic process where Name=' java. exe delete
cd D:\Server
start run.bat
```

#### **垃圾回收相关**

![image-20211119170915480](https://cuichonghe.oss-cn-shenzhen.aliyuncs.com/markdown/image-20211119170915480.png)

```shell
-XX:+PrintCommandLineFlags #查看命令行相关参数（包含使用的垃圾收集器）
#使用命令行指令：jinfo-flag相关垃圾回收器参数进程ID
```

##### Serial

```shell
#Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。Serial old是运行在Client模式下默认的老年代的垃圾回收器。
-XX:+UseSerialGC
#指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC,且老年代用Serial 0ld GC。可以获得最高的单线程收集效率。
```

##### **ParNew**

```shell
-XX:+UseParNewGC
#手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。
-XX:ParallelGCThreads=N
#限制线程数量，默认开启和CPU数据相同的线程数。
```

##### **Parallel**

```shell
XX:+UseParallelGC  #手动指定年轻代使用Parallel并行收集器执行内存回收任务。
XX:+UseParallelOldGC  #手动指定老年代都是使用并行回收收集器。
	#分别适用于新生代和老年代。默认jdk8是开启的。
	#上面两个参数，默认开启一个，另一个也会被开启。（互相激活）

XX:ParallelGCThreads
#设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。
	#·在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。
	#·当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8]。
	
XX:MaxGCPauseMillis
#设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒
	#为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。
	#对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量.所以服务器端适合Parallel,进行控制。
	#该参数使用需谨慎。

XX:GCTimeRatio
#垃圾收集时间占总时间的比例（=1/(N+1))。用于衡量吞吐量的大小。
	#取值范围（e,100)。默认值99,也就是垃圾回收时间不超过1%
	#与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。

XX:+UseAdaptiveSizePolicy
#设置Parallel Scavenge收集器具有自适应调节策略
	#在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。
	#在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio)和停顿时间（MaxGCPauseMills),让虚拟机自己完成调优工作
```

##### **CMS**

```shell
-XX:+UseConcMarkSweepGC #手动指定使用CMS收集器执行内存回收任务。
	#开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew(Young区用）+CMS(Old区用)+Serial Old的组合。

-XX:CMslnitiatingoccupanyFraction  #设置堆内存使用率的阙值，一旦达到该阀值，便开始进行回收。
	#JDK5及以前版本的默认值为68,即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%
	#如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阀值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数

-XX:+UseCMSCompactAtFullCollection
#用于指定在执行完FullGC后对内存空间进行压缩整理,以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。

-XX:CMSFullGCsBeforeCompaction #设置在执行多少次Full GC后对内存空间进行压缩整理。

-XX:ParallelCMSThreads #设置CMS的线程数量。
	#CMS默认启动的线程数是（ParallelGCThreads+3)/4,ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在

-XX:ConcGCThreads: #设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的；
-XX:+UseCMSInitiatingoccupancyonly:
#是否动态可调，用这个参数可以使CMS一直CMSInitiatingoccupancyFraction设定的值启动

-XX:+CMSScavengeBeforeRemark:
#强制hotspot虚拟机在cms remark阶段之前做一次minor gc,用于提高remark阶段的速度

-XX:+CMSClassUnloadingEnable:#如果有的话，启用回收Perm区（JDK8之前）
-XX:+CMSParallelInitialEnabled:
#用于开启CMS initial-mark阶段采用多线程的方式进行标记，用于提高标记速度，在Java8开始已经默认开启；

-XX:+CMSParallelRemarkEnabled:#用户开启CMS remark阶段采用多线程的方式进行重新标记,默认开启；

-XX:+ExplicitGCInvokesConcurrent、
-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
#这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期；
-XX:+CMSPrecleaningEnabled:#指定CMS是否需要进行Pre cleaning这个阶段
```

##### **G1**

```shell
-XX: +UseG1GC
#手动指定使用G1收集器执行内存回收任务。

-XX:G1HeapRegionSize
#设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。

-XX:MaxGCPauseMillis
#设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms

-XX:ParallelGCThread
#设置STW时GC线程数的值。最多设置为8

-XX: ConcGCThreads
#设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads)的1/4左右。

-XX:InitiatingHeapOccupancyPercent
#设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。

-XX:G1NewSizePercent、-XX:G1MaxNewSizePercent
#新生代占用整个堆内存的最小百分比（默认5%)、最大百分比（默认60%)

-XX:G1ReservePercent=10
#保留内存区域，防止 to space(Survivor中的to区）溢出
```

注意：G1收集器主要涉及到Mixed GC,Mixed GC会回收young区和部分old区

###### **G1关于Mixed GC调优常用参数**

```shell
-XX:InitiatingHeapOccupancyPercent:
#设置堆占用率的百分比（0到100)达到这个数值的时候触发global concurrent marking(全局并发标记）,默认为45%。值为0表示间断进行全局并发标记。

-XX:G1MixedGCLiveThresholdPercent:
#设置old区的region被回收时候的对象占比，默认占用率为85%。只有old区的region中存活的对象占用达到了这个百分比,才会在Mixed GC中被回收。

-XX:G1HeapWastePercent:
#在global concurrent marking(全局并发标记）结束之后，可以知道所有的区有多少空间要被回收，在每次young GC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC.

-XX:G1MixedGCCountTarget:
#一次global concurrent marking(全局并发标记）之后，最多执行Mixed GC的次数，默认是8。

-XX:G1OldCSetRegionThresholdPercent:
#设置Mixed GC收集周期中要收集的old region数的上限。默认值是Java堆的10%
```

#### **GC参数**

```shell
-XX:+TraceClassLoading  监控类的加载
-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间
-XX:+PrintGCApplicationConcurrentTime  垃圾收集之前打印出应用未中断的执行时间
-XX:+PrintReferenceGC 记录回收了多少种不同引用类型的引用
-XX:+PrintTenuringDistribution 让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布
-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储
-XX:NumberOfGClogFiles=1 GC日志文件的循环数目
-XX:GCLogFileSize=1M 控制GC日志文件的大小
```

#### **其他参数**

```shell
-XX:+DisableExplicitGC  禁止hotspot执行System.gc(),默认禁用
-XX:ReservedCodeCacheSize=<n>[g|m]k]、-XX:InitialCodeCacheSize=<n>[g|m|k]指定代码缓存的大小

-XX:+UseCodeCacheFlushing  
#使用该参数让jvm放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况
-XX:+DoEscapeAnalysis  开启逃逸分析
-XX:+UseBiasedLocking  开启偏向锁
-XX:+UseLargePages 开启使用大页面
-XX:+UseTLAB  使用TLAB,默认打开
-XX:+PrintTLAB  打印TLAB的使用情况
-XX:TLABSize 设置TLAB大小
```

